)]}'
{"version":3,"file":"/packages/iron:router.js","sources":["iron:router/lib/current_options.js","iron:router/lib/http_methods.js","iron:router/lib/route_controller.js","iron:router/lib/route_controller_client.js","iron:router/lib/route.js","iron:router/lib/router.js","iron:router/lib/hooks.js","iron:router/lib/helpers.js","iron:router/lib/router_client.js","iron:router/lib/plugins.js","iron:router/lib/global_router.js","iron:router/lib/templates.html"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,4E;AACA,6D;AACA,G;AACA,gD;;;;;;;;;;;;;;;;;;;ACJA,gB;AACA,Q;AACA,S;AACA,Q;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;ACLA,+E;AACA,a;AACA,+E;AACA,iC;AACA,mB;AACA,2C;AACA,+B;;AAEA,+E;AACA,qB;AACA,+E;AACA,qC;AACA,mC;AACA,iE;AACA,4B;AACA,2B;AACA,+B;AACA,+B;AACA,qB;;AAEA,mE;AACA,sE;AACA,qE;AACA,oE;AACA,wE;AACA,yC;;AAEA,mC;AACA,qC;AACA,yC;AACA,+C;;AAEA,uB;AACA,G;AACA,G;;AAEA,G;AACA,2E;AACA,E;AACA,iB;AACA,0C;AACA,uB;AACA,qB;AACA,wB;AACA,G;AACA,yD;AACA,uB;AACA,gF;AACA,+E;AACA,+E;AACA,2E;AACA,4E;AACA,kD;AACA,yE;AACA,mC;;AAEA,iB;AACA,+B;AACA,6B;;AAEA,qC;AACA,uC;AACA,qB;;AAEA,4D;AACA,kC;AACA,+B;AACA,qB;;AAEA,wB;AACA,4E;AACA,oC;AACA,E;;AAEA,+E;AACA,0D;AACA,0B;AACA,uC;AACA,yC;AACA,gC;AACA,gD;AACA,oC;AACA,mB;AACA,sD;AACA,oD;AACA,G;AACA,E;;AAEA,G;AACA,yE;AACA,2B;AACA,E;AACA,sB;AACA,qB;AACA,8B;AACA,iC;AACA,E;AACA,6D;AACA,gF;AACA,a;AACA,E;AACA,0E;AACA,4B;AACA,E;AACA,6E;AACA,yD;AACA,G;AACA,+E;AACA,kB;AACA,uC;;AAEA,wC;AACA,e;AACA,gB;AACA,4C;AACA,mD;AACA,gE;AACA,I;;AAEA,yD;AACA,mB;;AAEA,uB;AACA,wF;;AAEA,4C;AACA,oE;AACA,I;;AAEA,gC;AACA,gD;AACA,uB;AACA,K;AACA,I;;AAEA,uB;AACA,4B;AACA,kD;AACA,iD;AACA,4C;AACA,K;;AAEA,sB;AACA,4B;AACA,8D;AACA,0C;AACA,K;;AAEA,qB;AACA,4B;AACA,4B;AACA,4C;AACA,0C;AACA,K;AACA,K;;AAEA,sB;AACA,mB;AACA,8B;AACA,0D;AACA,4C;AACA,O;AACA,G;;AAEA,4B;AACA,uB;AACA,uB;AACA,uB;;AAEA,kB;AACA,E;;AAEA,G;AACA,gE;AACA,G;AACA,yE;AACA,wD;AACA,iD;AACA,qB;AACA,iB;AACA,G;AACA,sB;AACA,E;;AAEA,mD;AACA,qB;AACA,E;;AAEA,wD;AACA,sB;AACA,c;AACA,E;;AAEA,uC;;;;;;;;;;;;;;;;;;;ACjMA,+E;AACA,a;AACA,+E;AACA,iC;AACA,mB;AACA,2C;AACA,4D;;AAEA,+E;AACA,qB;AACA,+E;AACA,G;AACA,kC;AACA,G;AACA,qD;AACA,wD;AACA,2B;AACA,2C;AACA,gC;AACA,E;;AAEA,mD;AACA,2B;AACA,qB;AACA,E;;AAEA,iE;AACA,gC;AACA,8B;AACA,+E;AACA,8B;AACA,mB;AACA,8B;AACA,mB;AACA,wC;AACA,6C;AACA,qB;AACA,K;;AAEA,uD;AACA,0B;AACA,0B;AACA,Y;;AAEA,sC;AACA,mB;;AAEA,4C;AACA,qB;AACA,yB;AACA,qB;AACA,wC;AACA,qB;AACA,K;;AAEA,gB;AACA,I;;AAEA,0D;AACA,sB;AACA,iC;AACA,W;;AAEA,sB;;AAEA,0B;AACA,iC;AACA,8B;;AAEA,c;AACA,E;;AAEA,G;AACA,2E;AACA,8E;AACA,2B;AACA,G;AACA,kE;AACA,sD;AACA,sF;;AAEA,kB;;AAEA,sD;AACA,gC;AACA,kC;AACA,+B;AACA,sC;AACA,O;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,6E;AACA,0E;AACA,mE;AACA,E;AACA,e;AACA,E;AACA,mE;AACA,E;AACA,2E;AACA,8E;AACA,uD;AACA,G;AACA,mE;AACA,kB;;;AAGA,0D;AACA,uD;AACA,uD;AACA,sB;AACA,I;AACA,4E;AACA,6B;AACA,I;AACA,+E;AACA,sE;AACA,qD;AACA,uC;AACA,kC;AACA,K;;;AAGA,0E;AACA,0E;AACA,0E;AACA,yE;AACA,wD;AACA,gD;;AAEA,wC;AACA,iC;AACA,K;;AAEA,yD;AACA,4D;AACA,yB;AACA,6C;;AAEA,6E;AACA,8E;AACA,+E;AACA,0C;AACA,qB;AACA,2B;;AAEA,+B;AACA,yC;AACA,qC;AACA,O;AACA,I;;AAEA,qC;AACA,yC;AACA,8C;AACA,yC;AACA,O;AACA,I;;AAEA,+B;AACA,2C;;AAEA,6E;AACA,uB;AACA,a;;AAEA,gC;AACA,4C;;AAEA,sE;AACA,wE;AACA,yE;AACA,wE;AACA,a;;AAEA,+C;AACA,8D;AACA,mE;AACA,K;;AAEA,oD;AACA,mC;AACA,K;;AAEA,kC;AACA,uC;AACA,yC;;AAEA,4E;AACA,wE;;AAEA,e;AACA,qC;AACA,4E;AACA,iD;AACA,oC;AACA,mD;AACA,gB;AACA,iB;AACA,S;AACA,c;AACA,e;AACA,O;AACA,M;;AAEA,uC;AACA,wC;AACA,sC;AACA,qD;AACA,gB;AACA,iB;AACA,S;AACA,c;AACA,e;AACA,O;AACA,K;AACA,uB;;AAEA,uD;AACA,kD;AACA,uB;AACA,qD;AACA,G;;AAEA,mE;AACA,+C;;AAEA,4E;AACA,2B;AACA,sC;AACA,kE;;AAEA,2C;;AAEA,iE;AACA,yB;AACA,kC;AACA,4E;AACA,oC;AACA,8B;AACA,qD;AACA,iG;AACA,K;;AAEA,yE;AACA,6E;AACA,yE;AACA,mE;AACA,gB;AACA,0C;AACA,E;;AAEA,G;AACA,0E;AACA,G;AACA,gD;AACA,gB;AACA,E;;AAEA,G;AACA,4E;AACA,yD;AACA,G;AACA,wD;AACA,yC;AACA,sE;AACA,E;;AAEA,G;AACA,+C;AACA,G;AACA,+D;AACA,6C;AACA,sB;AACA,2C;AACA,8C;AACA,E;;AAEA,G;AACA,oE;AACA,0E;AACA,0C;AACA,G;AACA,iE;AACA,wB;AACA,+B;AACA,yC;AACA,uE;AACA,yB;AACA,kB;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,G;AACA,2E;AACA,G;AACA,uD;AACA,kB;AACA,qD;;AAEA,+D;;;AAGA,uB;AACA,Q;AACA,uC;AACA,Q;AACA,yD;AACA,oC;AACA,K;AACA,E;;AAEA,G;AACA,4B;AACA,G;AACA,8C;AACA,4C;;AAEA,wB;AACA,6B;AACA,oC;AACA,wB;AACA,E;;AAEA,G;AACA,2C;AACA,E;AACA,4E;AACA,G;AACA,kD;AACA,sD;AACA,E;;AAEA,G;AACA,sE;AACA,E;AACA,oE;AACA,mE;AACA,uE;AACA,wE;AACA,8E;AACA,wB;AACA,E;AACA,W;AACA,E;AACA,oD;AACA,E;AACA,wB;AACA,U;AACA,a;AACA,U;AACA,M;AACA,G;AACA,iF;AACA,kB;AACA,uD;AACA,2B;AACA,uB;AACA,sB;AACA,K;AACA,K;AACA,E;;AAEA,qB;AACA,2D;AACA,6E;;AAEA,oD;AACA,yD;AACA,0C;AACA,C;;;;;;;;;;;;;;;;;;;ACxXA,mB;AACA,2C;AACA,+B;;AAEA,+E;AACA,U;AACA,+E;AACA,sC;AACA,yC;AACA,0B;AACA,6B;AACA,8B;AACA,8C;AACA,G;;AAEA,+B;AACA,iB;AACA,wB;AACA,G;;AAEA,0B;;AAEA,2D;AACA,mD;AACA,G;;AAEA,yE;AACA,e;AACA,wB;;AAEA,gC;AACA,0C;;AAEA,+E;AACA,qB;AACA,2C;;AAEA,4E;AACA,6B;AACA,2C;AACA,0D;AACA,kD;;AAEA,+C;AACA,0C;AACA,wD;AACA,gD;;;AAGA,wC;AACA,sB;;AAEA,+B;AACA,qD;AACA,kB;AACA,Q;AACA,kE;AACA,+C;AACA,G;;AAEA,qB;AACA,e;AACA,E;;AAEA,G;AACA,6E;AACA,qD;AACA,G;AACA,uC;AACA,2C;AACA,E;;AAEA,G;AACA,qE;AACA,E;AACA,iC;AACA,E;AACA,0D;AACA,gF;AACA,gC;AACA,E;AACA,G;AACA,yD;AACA,kB;;AAEA,uC;AACA,sB;AACA,qC;AACA,sE;AACA,sC;AACA,0E;AACA,U;AACA,yB;AACA,Y;AACA,e;AACA,K;AACA,I;;AAEA,iC;AACA,8C;AACA,I;;AAEA,a;AACA,4B;;AAEA,oC;AACA,oD;AACA,mC;;AAEA,8E;AACA,iC;AACA,uD;AACA,4C;;AAEA,8E;AACA,8B;AACA,4E;AACA,kB;;AAEA,qD;AACA,M;AACA,2B;AACA,E;;;AAGA,G;AACA,yC;AACA,G;AACA,uD;AACA,0B;AACA,2C;AACA,uB;AACA,gC;AACA,kB;AACA,E;;AAEA,kE;AACA,E;;AAEA,G;AACA,8C;AACA,G;AACA,0D;AACA,gF;AACA,mB;AACA,uE;AACA,4C;AACA,E;;AAEA,G;AACA,yC;AACA,G;AACA,mD;AACA,+C;AACA,E;;AAEA,G;AACA,2E;AACA,+B;AACA,G;AACA,kD;AACA,wC;AACA,+D;;AAEA,0C;AACA,wC;AACA,qB;AACA,E;;AAEA,G;AACA,qD;AACA,G;AACA,0C;AACA,mC;AACA,E;;AAEA,G;AACA,8C;AACA,E;AACA,W;AACA,qC;AACA,2B;AACA,4B;AACA,2B;AACA,G;AACA,wC;AACA,2C;AACA,wD;AACA,iC;;AAEA,4C;AACA,4E;AACA,iC;AACA,wD;AACA,qB;;AAEA,gF;AACA,sB;AACA,gC;AACA,kB;AACA,O;;AAEA,gB;AACA,I;AACA,G;;AAEA,mB;;;;;;;;;;;;;;;;;;;AC9MA,+E;AACA,a;AACA,+E;AACA,2C;AACA,mB;AACA,yB;AACA,2B;AACA,+B;;AAEA,6B;AACA,2C;AACA,4B;AACA,oC;AACA,wF;AACA,8B;AACA,mB;AACA,mB;AACA,a;AACA,G;;AAEA,0B;AACA,sC;;AAEA,sD;AACA,2B;;AAEA,8E;AACA,c;AACA,qB;;AAEA,4D;AACA,6B;;AAEA,gC;AACA,uC;;AAEA,gD;AACA,yB;;AAEA,mE;AACA,kC;;AAEA,8B;AACA,8B;AACA,6C;AACA,uB;AACA,O;AACA,K;;AAEA,gB;AACA,E;;AAEA,8C;;AAEA,iD;AACA,kB;;AAEA,0B;;AAEA,kC;AACA,e;AACA,gB;;AAEA,yB;AACA,mB;;AAEA,mB;AACA,I;;AAEA,0C;AACA,+D;AACA,wB;AACA,+D;AACA,iC;AACA,S;;AAEA,2B;AACA,K;AACA,K;;AAEA,oC;AACA,kC;;AAEA,c;AACA,E;;AAEA,G;AACA,qE;AACA,G;AACA,sC;AACA,uB;AACA,E;;AAEA,E;AACA,mE;AACA,kD;AACA,mC;AACA,oB;AACA,sB;AACA,wC;AACA,iC;AACA,U;AACA,sB;AACA,sB;AACA,wC;AACA,qC;AACA,G;;AAEA,c;AACA,E;AACA,E;;AAEA,wF;AACA,oD;AACA,8E;AACA,2J;;AAEA,+B;AACA,c;AACA,qB;AACA,G;;AAEA,wC;;AAEA,oB;;AAEA,0B;AACA,qB;;AAEA,wE;AACA,oD;;AAEA,wB;AACA,0B;AACA,sB;AACA,E;AACA,4C;AACA,qI;AACA,4C;;AAEA,0B;;AAEA,uC;AACA,sC;;AAEA,e;AACA,E;;AAEA,G;AACA,sD;AACA,G;AACA,kD;AACA,gD;AACA,6C;AACA,4B;AACA,G;;AAEA,c;AACA,E;;AAEA,+D;AACA,qC;AACA,+J;AACA,8C;AACA,E;;AAEA,8D;AACA,qC;AACA,8J;AACA,6C;AACA,E;;AAEA,G;AACA,0C;AACA,G;AACA,6D;AACA,wC;AACA,uC;AACA,iB;;AAEA,0B;;AAEA,Y;AACA,kD;AACA,gE;AACA,M;AACA,qC;AACA,6D;;AAEA,2B;AACA,+D;AACA,oB;AACA,E;;AAEA,2D;AACA,mC;AACA,c;AACA,E;;AAEA,6D;AACA,qC;AACA,c;AACA,E;;AAEA,kD;AACA,kC;AACA,4C;AACA,M;AACA,qC;AACA,E;;AAEA,oD;AACA,oC;AACA,8C;AACA,M;AACA,oD;AACA,E;;AAEA,G;AACA,E;AACA,gE;AACA,+E;AACA,E;AACA,sE;AACA,qE;AACA,2C;AACA,uB;AACA,c;AACA,E;AACA,G;;AAEA,0D;AACA,kB;;AAEA,0B;;AAEA,kC;AACA,e;AACA,gB;AACA,8B;AACA,mB;AACA,Q;AACA,qB;AACA,G;;AAEA,mB;AACA,yC;AACA,qB;AACA,6C;;AAEA,sE;;AAEA,qC;AACA,uB;AACA,yB;AACA,+E;AACA,0E;AACA,wE;AACA,0E;AACA,yE;AACA,gF;AACA,2E;AACA,0D;AACA,wD;AACA,O;AACA,I;;AAEA,wD;AACA,c;AACA,E;;AAEA,G;AACA,6E;AACA,+E;AACA,uB;AACA,G;AACA,mD;AACA,oB;;AAEA,6C;AACA,uB;AACA,c;;AAEA,6C;AACA,mD;AACA,W;AACA,uB;AACA,4C;AACA,mC;AACA,G;;AAEA,0C;AACA,sD;AACA,E;;AAEA,G;AACA,E;AACA,qE;AACA,sD;AACA,E;AACA,sD;AACA,oE;AACA,wD;AACA,c;AACA,E;AACA,G;;AAEA,kD;AACA,kB;AACA,iB;;AAEA,kD;AACA,+B;;AAEA,0D;AACA,gB;;AAEA,wD;AACA,gB;;AAEA,0B;AACA,K;;AAEA,e;AACA,E;;AAEA,qB;AACA,U;AACA,Y;AACA,mB;AACA,kB;AACA,W;;AAEA,4C;AACA,6C;AACA,mD;AACA,qD;AACA,W;;AAEA,+C;AACA,kB;AACA,6B;AACA,2B;AACA,oB;AACA,E;;AAEA,G;AACA,uC;AACA,G;AACA,kB;;;AAGA,G;AACA,kD;AACA,G;AACA,oB;;AAEA,G;AACA,6C;AACA,G;;AAEA,2C;AACA,qD;AACA,sC;AACA,I;AACA,G;;AAEA,G;AACA,uC;AACA,G;AACA,wD;AACA,W;;AAEA,qC;AACA,oB;AACA,wC;AACA,yC;;AAEA,Y;AACA,yE;;AAEA,wB;AACA,iC;;AAEA,c;AACA,E;;AAEA,qB;;;;;;;;;;;;;;;;;;;ACnYA,sC;AACA,K;AACA,4C;AACA,K;AACA,mF;AACA,wB;AACA,K;;AAEA,K;AACA,mD;AACA,K;AACA,6F;AACA,+B;AACA,K;AACA,C;;AAEA,G;AACA,sE;AACA,8E;AACA,oC;AACA,G;;AAEA,oC;AACA,qC;AACA,qB;AACA,gB;AACA,W;AACA,G;;AAEA,sD;AACA,kD;AACA,uB;AACA,E;;AAEA,G;AACA,gF;AACA,Q;AACA,G;AACA,yC;AACA,sB;AACA,gB;AACA,W;AACA,G;;AAEA,uC;AACA,gB;AACA,uD;;AAEA,mC;AACA,yC;AACA,2D;AACA,2B;AACA,a;AACA,K;AACA,G;;AAEA,wC;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC1DA,+E;AACA,a;AACA,+E;AACA,2B;AACA,2C;AACA,sD;;AAEA,+E;AACA,gB;AACA,+E;;AAEA,G;AACA,sE;AACA,kB;AACA,G;AACA,sE;AACA,6B;AACA,I;;AAEA,G;AACA,8E;AACA,uB;AACA,G;AACA,iD;AACA,gB;;AAEA,6B;AACA,6B;AACA,iC;AACA,I;;AAEA,qC;;AAEA,oB;;AAEA,gB;AACA,yB;AACA,uB;AACA,0C;AACA,6C;;AAEA,uC;AACA,kF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,wD;AACA,G;;AAEA,c;AACA,G;;AAEA,G;AACA,8E;AACA,uB;AACA,G;AACA,gD;AACA,gB;;AAEA,6B;AACA,6B;AACA,iC;AACA,I;;AAEA,qC;;AAEA,oB;AACA,e;AACA,yB;AACA,uB;AACA,0C;AACA,6C;;AAEA,uC;AACA,iF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,sD;AACA,G;;AAEA,a;AACA,G;;AAEA,G;AACA,6C;AACA,E;AACA,W;AACA,qE;AACA,uC;AACA,gB;AACA,G;AACA,sE;AACA,kB;AACA,yD;;AAEA,+B;AACA,6I;;AAEA,oB;AACA,gB;AACA,yB;AACA,uB;AACA,6B;AACA,mF;AACA,uC;AACA,gB;;AAEA,iF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,wD;AACA,G;;AAEA,0E;AACA,6B;AACA,6D;AACA,oB;;AAEA,iC;AACA,sD;AACA,kB;AACA,oD;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACxJA,2C;AACA,mB;AACA,yB;AACA,+B;AACA,0D;AACA,kD;;AAEA,G;AACA,kC;AACA,G;AACA,4C;AACA,kB;;AAEA,gD;AACA,iC;;AAEA,sB;AACA,4B;;AAEA,sB;AACA,yC;;AAEA,6B;AACA,mC;;AAEA,iC;AACA,qE;;AAEA,8B;AACA,kD;AACA,4C;AACA,yC;AACA,O;AACA,K;AACA,E;;AAEA,G;AACA,wE;AACA,gC;AACA,G;AACA,8C;AACA,+B;AACA,c;AACA,E;;AAEA,G;AACA,6E;AACA,yB;AACA,G;AACA,2C;AACA,+B;AACA,E;;AAEA,uD;AACA,oC;AACA,yC;AACA,E;AACA,sF;AACA,E;;AAEA,qD;AACA,qC;AACA,E;;AAEA,2D;AACA,kB;;AAEA,4E;;AAEA,2C;AACA,uC;AACA,qC;;AAEA,6B;;AAEA,mE;AACA,qE;AACA,mB;AACA,mD;AACA,+D;AACA,+D;AACA,8C;AACA,U;AACA,4D;AACA,+B;AACA,qD;AACA,G;;AAEA,iE;AACA,iE;AACA,qD;AACA,8B;AACA,mC;;AAEA,uC;;AAEA,wD;AACA,Y;AACA,gB;AACA,U;AACA,0E;AACA,yC;AACA,e;AACA,kF;AACA,iE;AACA,qE;AACA,0B;AACA,U;AACA,mC;AACA,kF;;AAEA,qE;;AAEA,8B;AACA,0G;AACA,+D;AACA,6B;AACA,e;AACA,c;AACA,iC;AACA,O;AACA,K;AACA,K;;AAEA,qE;AACA,oE;AACA,mE;AACA,sC;AACA,4C;AACA,+B;;AAEA,oB;AACA,E;;AAEA,G;AACA,iC;AACA,G;AACA,wC;AACA,4B;AACA,iC;AACA,E;;AAEA,E;AACA,6C;AACA,oE;AACA,G;AACA,uD;AACA,O;AACA,+B;AACA,oD;AACA,e;AACA,mD;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,G;AACA,sC;AACA,kB;AACA,mB;;AAEA,6E;AACA,mB;AACA,kC;AACA,+B;AACA,0C;;AAEA,uE;AACA,2C;;AAEA,2D;AACA,6C;AACA,8B;AACA,Y;AACA,mC;AACA,sE;AACA,0B;AACA,yC;AACA,K;;AAEA,uB;AACA,K;AACA,E;;AAEA,G;AACA,2D;AACA,G;AACA,qC;AACA,uB;AACA,W;;AAEA,gC;AACA,qC;;AAEA,8B;AACA,mC;;AAEA,0B;AACA,E;;AAEA,G;AACA,2E;AACA,E;AACA,W;AACA,yE;AACA,G;AACA,mE;AACA,kB;AACA,0B;AACA,W;;AAEA,0B;;AAEA,qC;AACA,mB;AACA,2B;AACA,U;AACA,yB;AACA,6C;AACA,6E;AACA,+E;AACA,G;;AAEA,gE;AACA,qC;AACA,kC;AACA,E;;;;;;;;;;;;;;;;;;;ACnOA,G;AACA,iD;AACA,G;AACA,qD;AACA,4C;AACA,E;;AAEA,G;AACA,sD;AACA,G;AACA,0D;AACA,iD;AACA,E;;;;;;;;;;;;;;;;;;;ACZA,yB;;AAEA,sB;AACA,uD;AACA,C;;;;;;;;;;;;;;;;;;;;ACHA,+C;AACA,kG;AACA,kB;AACA,mB;AACA,yD;AACA,yB;AACA,0C;AACA,iH;AACA,kD;AACA,2B;AACA,I;;AAEA,+C;AACA,kG;AACA,kB;AACA,0hC;AACA,I","sourcesContent":["/**\n * Allows for dynamic scoping of options variables. Primarily intended to be\n * used in the RouteController.prototype.lookupOption method.\n */\nCurrentOptions = new Meteor.EnvironmentVariable;\n","HTTP_METHODS = [\n  'get',\n  'post',\n  'put',\n  'delete',\n];\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\nRouteController = Controller.extend({\n  constructor: function (options) {\n    RouteController.__super__.constructor.apply(this, arguments);\n    options = options || {};\n    this.options = options;\n    this._onStopCallbacks = [];\n    this.route = options.route;\n    this.params = [];\n\n    // Sometimes the data property can be defined on route options,\n    // or even on the global router config. And people will expect the\n    // data function to be available on the controller instance if it\n    // is defined anywhere in the chain. This ensure that if we have\n    // a data function somewhere in the chain, you can call this.data().\n    var data = this.lookupOption('data');\n\n    if (typeof data === 'function')\n      this.data = _.bind(data, this);\n    else if (typeof data !== 'undefined')\n      this.data = function () { return data; };\n\n    this.init(options);\n  }\n});\n\n/**\n * Returns an option value following an \"options chain\" which is this path:\n *\n *   this.options\n *   this (which includes the proto chain)\n *   this.route.options\n *   dynamic variable\n *   this.router.options\n */\nRouteController.prototype.lookupOption = function (key) {\n  // this.route.options\n  // NOTE: we've debated whether route options should come before controller but\n  // Tom has convinced me that it's easier for people to think about overriding\n  // controller stuff at the route option level. However, this has the possibly\n  // counterintuitive effect that if you define this.someprop = true on the\n  // controller instance, and you have someprop defined as an option on your\n  // Route, the route option will take precedence.\n  if (this.route && this.route.options && _.has(this.route.options, key))\n    return this.route.options[key];\n\n  // this.options\n  if (_.has(this.options, key))\n    return this.options[key];\n\n  // \"this\" object or its proto chain\n  if (typeof this[key] !== 'undefined')\n    return this[key];\n\n  // see if we have the CurrentOptions dynamic variable set.\n  var opts = CurrentOptions.get();\n  if (opts && _.has(opts, key))\n    return opts[key];\n\n  // this.router.options\n  if (this.router && this.router.options && _.has(this.router.options, key))\n    return this.router.options[key];\n};\n\nRouteController.prototype.configureFromUrl = function (url, context, options) {\n  assert(typeof url === 'string', 'url must be a string');\n  context = context || {};\n  this.request = context.request || {};\n  this.response = context.response || {};\n  this.url = context.url || url;\n  this.originalUrl = context.originalUrl || url;\n  this.method = this.request.method;\n  if (this.route) {\n    // pass options to that we can set reactive: false\n    this.setParams(this.route.params(url), options);\n  }\n};\n\n/**\n * Returns an array of hook functions for the given hook names. Hooks are\n * collected in this order:\n *\n * router global hooks\n * route option hooks\n * prototype of the controller\n * this object for the controller\n *\n * For example, this.collectHooks('onBeforeAction', 'before')\n * will return an array of hook functions where the key is either onBeforeAction\n * or before.\n *\n * Hook values can also be strings in which case they are looked up in the\n * Iron.Router.hooks object.\n *\n * TODO: Add an options last argument which can specify to only collect hooks\n * for a particular environment (client, server or both).\n */\nRouteController.prototype._collectHooks = function (/* hook1, alias1, ... */) {\n  var self = this;\n  var hookNames = _.toArray(arguments);\n\n  var getHookValues = function (value) {\n    if (!value)\n      return [];\n    var lookupHook = self.router.lookupHook;\n    var hooks = _.isArray(value) ? value : [value];\n    return _.map(hooks, function (h) { return lookupHook(h); });\n  };\n\n  var collectInheritedHooks = function (ctor, hookName) {\n    var hooks = [];\n\n    if (ctor.__super__)\n      hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor, hookName));\n\n    return _.has(ctor.prototype, hookName) ?\n      hooks.concat(getHookValues(ctor.prototype[hookName])) : hooks;\n  };\n\n  var eachHook = function (cb) {\n    for (var i = 0; i < hookNames.length; i++) {\n      cb(hookNames[i]);\n    }\n  };\n\n  var routerHooks = [];\n  eachHook(function (hook) {\n    var name = self.route && self.route.getName();\n    var hooks = self.router.getHooks(hook, name);\n    routerHooks = routerHooks.concat(hooks);\n  });\n\n  var protoHooks = [];\n  eachHook(function (hook) {\n    var hooks = collectInheritedHooks(self.constructor, hook);\n    protoHooks = protoHooks.concat(hooks);\n  });\n\n  var thisHooks = [];\n  eachHook(function (hook) {\n    if (_.has(self, hook)) {\n      var hooks = getHookValues(self[hook]);\n      thisHooks = thisHooks.concat(hooks);\n    }\n  });\n\n  var routeHooks = [];\n  if (self.route) {\n    eachHook(function (hook) {\n      var hooks = getHookValues(self.route.options[hook]);\n      routeHooks = routeHooks.concat(hooks);\n    });\n  }\n\n  var allHooks = routerHooks\n    .concat(routeHooks)\n    .concat(protoHooks)\n    .concat(thisHooks);\n\n  return allHooks;\n};\n\n/**\n * Runs each hook and returns the number of hooks that were run.\n */\nRouteController.prototype.runHooks = function (/* hook, alias1, ...*/ ) {\n  var hooks = this._collectHooks.apply(this, arguments);\n  for (var i = 0, l = hooks.length; i < l; i++) {\n    var h = hooks[i];\n    h.call(this);\n  }\n  return hooks.length;\n};\n\nRouteController.prototype.getParams = function () {\n  return this.params;\n};\n\nRouteController.prototype.setParams = function (value) {\n  this.params = value;\n  return this;\n};\n\nIron.RouteController = RouteController;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar debug = Iron.utils.debug('iron-router:RouteController');\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\n/**\n * Client specific initialization.\n */\nRouteController.prototype.init = function (options) {\n  RouteController.__super__.init.apply(this, arguments);\n  this._computation = null;\n  this._paramsDep = new Tracker.Dependency;\n  this.location = Iron.Location;\n};\n\nRouteController.prototype.getParams = function () {\n  this._paramsDep.depend();\n  return this.params;\n};\n\nRouteController.prototype.setParams = function (value, options) {\n  var equals = function (a, b) {\n    if (!(a instanceof Array))\n      throw new Error(\"you called equals with a non array value in setParams\");\n    if (!(b instanceof Array))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options))\n        return false;\n    }\n\n    // now check all of the hasOwn properties of params\n    var aKeys = _.keys(a);\n    var bKeys = _.keys(b);\n    var key;\n\n    if (aKeys.length !== bKeys.length)\n      return false;\n\n    for (var i = 0; i < aKeys.length; i++) {\n      key = aKeys[i];\n      if (!_.has(b, key))\n        return false;\n      if (!EJSON.equals(a[key], b[key]))\n        return false;\n    }\n\n    return true;\n  };\n\n  // this won't work because the array values are the same\n  // most of the time.\n  if (equals(this.params, value))\n    return;\n\n  this.params = value;\n\n  options = options || {};\n  if (options.reactive !== false)\n    this._paramsDep.changed();\n\n  return this;\n};\n\n/**\n * Let this controller run a dispatch process. This function will be called\n * from the router. That way, any state associated with the dispatch can go on\n * the controller instance.\n */\nRouteController.prototype.dispatch = function (stack, url, done) {\n  if (this._computation && !this._computation.stopped)\n    throw new Error(\"RouteController computation is already running. Stop it first.\");\n\n  var self = this;\n\n  // break the computation chain with any parent comps\n  Deps.nonreactive(function () {\n    Deps.autorun(function (comp) {\n      self._computation = comp;\n      stack.dispatch(url, self, done);\n    });\n  });\n\n  return self;\n};\n\n/**\n * Run a route. When the router runs its middleware stack, it can run regular\n * middleware functions or it can run a route. There should only one route\n * object per path as where there may be many middleware functions.\n *\n * For example:\n *\n *   \"/some/path\" => [middleware1, middleware2, route, middleware3]\n *\n * When a route is dispatched, it tells the controller to _runRoute so that\n * the controller can controll the process. At this point we should already be\n * in a dispatch so a computation should already exist.\n */\nRouteController.prototype._runRoute = function (route, url, done) {\n  var self = this;\n\n\n  // this will now be where you can put your subscriptions\n  // instead of waitOn. If you use waitOn, it will also\n  // add the result to the wait list, but will also use\n  // the loading hook.\n  //\n  // Similar to waitOn, we'll collect these just like hooks. See the comment\n  // below on the waitOnList.\n  //\n  // If you don't want the subscription to affect the readiness of the waitlist\n  // then just don't return the subscription handle from the function.\n  var subsList = this._collectHooks('subscriptions');\n  _.each(subsList, function (subFunc) {\n    self.wait(subFunc.call(self));\n  });\n\n\n  // waitOn isn't really a 'hook' but we use the _collectHooks method here\n  // because I want an array of values collected in the same order that we\n  // collect regular hooks (router global, route option, controller proto,\n  // controller inst object. Then we need to map over the results to make\n  // sure the thisArg is set to the controller instance.\n  var waitOnList = this._collectHooks('waitOn');\n\n  _.each(waitOnList, function (waitOn) {\n    self.wait(waitOn.call(self));\n  });\n\n  // if we have a waitOn option, the loading hook will be\n  // added at the end of the before hook stack, right before\n  // the action function.\n  var useLoadingHook = waitOnList.length > 0;\n\n  // start the rendering transaction so we record which regions were rendered\n  // into so we can clear the unused regions later. the callback function will\n  // get called automatically on the next flush, OR if beginRendering is called\n  // again before the afterFlush callback.\n  var previousLayout;\n  var previousMainTemplate;\n\n  var getLayout = function () {\n    return Deps.nonreactive(function () {\n      return self._layout.template();\n    });\n  };\n\n  var getMainTemplate = function () {\n    return Deps.nonreactive(function () {\n      var region = self._layout._regions.main;\n      return region && region.template();\n    });\n  };\n\n  var prevLayout = getLayout();\n  var prevMainTemplate = getMainTemplate();\n\n  this.beginRendering(function onCompleteRenderingTransaction (usedRegions) {\n    if (self.isStopped)\n      return;\n\n    var curLayout = getLayout();\n    var curMainTemplate = getMainTemplate();\n\n    // in the case where we're using the same layout and main template\n    // across route changes don't automatically clear the unused regions\n    // because we could have static content in them that we want to keep!\n    if (prevLayout === curLayout && prevMainTemplate == curMainTemplate)\n      return;\n\n    var allRegions = self._layout.regionKeys();\n    var unusedRegions = _.difference(allRegions, usedRegions);\n    _.each(unusedRegions, function (r) { self._layout.clear(r); });\n  });\n\n  this.layout(this.lookupOption('layoutTemplate'), {\n    data: this.lookupOption('data')\n  });\n\n  var stack = new MiddlewareStack;\n  var onRunStack = new MiddlewareStack;\n  var onRerunStack = new MiddlewareStack;\n\n  onRunStack.append(this._collectHooks('onRun', 'load'), {where: 'client'});\n  onRerunStack.append(this._collectHooks('onRerun'), {where: 'client'});\n\n  stack.append(\n    function onRun (req, res, next) {\n      if (this._computation.firstRun && !RouteController._hasJustReloaded) {\n        RouteController._hasJustReloaded = false;\n        if (onRunStack.length > 0) {\n          onRunStack.dispatch(req.url, this, next);\n        } else {\n          next();\n        }\n      } else {\n        next();\n      }\n    },\n\n    function onRerun (req, res, next) {\n      if (!this._computation.firstRun) {\n        if (onRerunStack.length > 0) {\n          onRerunStack.dispatch(req.url, this, next);\n        } else {\n          next();\n        }\n      } else {\n        next();\n      }\n    }\n  , {where: 'client'});\n\n  // make sure the loading hook is the first one to run\n  // before any of the other onBeforeAction hooks.\n  if (useLoadingHook) {\n    stack.push(Iron.Router.hooks.loading.bind(self));\n  }\n\n  var beforeHooks = this._collectHooks('onBeforeAction', 'before');\n  stack.append(beforeHooks, {where: 'client'});\n\n  // make sure the action stack has at least one handler on it that defaults\n  // to the 'action' method\n  if (route._actionStack.length === 0)\n    route._actionStack.push(route._path, 'action', route.options);\n\n  stack = stack.concat(route._actionStack);\n\n  // the \"context\" is the current instance of the RouteController\n  this._rendered = false;\n  stack.dispatch(url, this, done);\n  // we put this in an afterFlush to let a redirected route have a chance to\n  //   start and to stop this route.\n  Deps.afterFlush(function() {\n    Iron.utils.warn(self._rendered || self.isStopped,\n      \"Route dispatch never rendered. Did you forget to call this.next() in an onBeforeAction?\");\n  });\n\n  // run the after hooks. Note, at this point we're out of the middleware\n  // stack way of doing things. So after actions don't call this.next(). They\n  // run just like a regular hook. In contrast, before hooks have to call\n  // this.next() to progress to the next handler, just like Connect\n  // middleware.\n  this.runHooks('onAfterAction', 'after');\n};\n\n/**\n * The default action for the controller simply renders the main template.\n */\nRouteController.prototype.action = function () {\n  this.render();\n};\n\n/**\n * Returns the name of the main template for this controller. If no explicit\n * value is found we will guess the name of the template.\n */\nRouteController.prototype.lookupTemplate = function () {\n  return this.lookupOption('template') ||\n    (this.router && this.router.toTemplateName(this.route.getName()));\n};\n\n/**\n * The regionTemplates for the RouteController.\n */\nRouteController.prototype.lookupRegionTemplates = function () {\n  return this.lookupOption('yieldRegions') ||\n    // XXX: deprecated\n    this.lookupOption('regionTemplates') ||\n    this.lookupOption('yieldTemplates') || {};\n};\n\n/**\n * Overrides Controller.prototype.render to automatically render the\n * controller's main template and region templates or just render a region\n * template if the arguments are provided.\n */\nRouteController.prototype.render = function (template, options) {\n  this._rendered = true;\n  if (arguments.length === 0) {\n    var template = this.lookupTemplate();\n    var result = RouteController.__super__.render.call(this, template);\n    this.renderRegions();\n    return result;\n  } else {\n    return RouteController.__super__.render.call(this, template, options);\n  }\n};\n\n/**\n * Render all region templates into their respective regions in the layout.\n */\nRouteController.prototype.renderRegions = function () {\n  var self = this;\n  var regionTemplates = this.lookupRegionTemplates();\n\n  debug('regionTemplates: ' + JSON.stringify(regionTemplates));\n\n\n  // regionTemplates =>\n  //   {\n  //     \"MyTemplate\": {to: 'MyRegion'}\n  //   }\n  _.each(regionTemplates, function (opts, templateName) {\n    self.render(templateName, opts);\n  });\n};\n\n/**\n * Stop the RouteController.\n */\nRouteController.prototype.stop = function () {\n  RouteController.__super__.stop.call(this);\n\n  if (this._computation)\n    this._computation.stop();\n  this.runHooks('onStop', 'unload');\n  this.isStopped = true;\n};\n\n/**\n * Just proxies to the go method of router.\n *\n * It used to have more significance. Keeping because people are used to it.\n */\nRouteController.prototype.redirect = function () {\n  return this.router.go.apply(this.router, arguments);\n};\n\n/**\n * Calls Meteor.subscribe but extends the handle with a wait() method.\n *\n * The wait method adds the subscription handle to this controller's\n * wait list. This is equivalent to returning a subscription handle\n * from the waitOn function. However, using the waitOn function has the\n * benefit that it will be called before any other hooks. So if you want\n * to use the \"loading\" hooks for example, you'll want the wait list populated\n * before the hook runs.\n *\n * Example:\n *\n *   this.subscribe('item', this.params._id).wait();\n *\n *   if (this.ready()) {\n *     ...\n *   } else {\n *     ...\n *   }\n */\nRouteController.prototype.subscribe = function (/* same as Meteor.subscribe */) {\n  var self = this;\n  var handle = Meteor.subscribe.apply(this, arguments);\n  return _.extend(handle, {\n    wait: function () {\n      self.wait(this);\n    }\n  });\n};\n\nif (Meteor._reload) {\n  // just register the fact that a migration _has_ happened\n  Meteor._reload.onMigrate('iron-router', function() { return [true, true]});\n\n  // then when we come back up, check if it it's set\n  var data = Meteor._reload.migrationData('iron-router');\n  RouteController._hasJustReloaded = data;\n}\n","var Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* Both */\n/*****************************************************************************/\nRoute = function (path, fn, options) {\n  var route = function (req, res, next) {\n    var controller = this;\n    controller.request = req;\n    controller.response = res;\n    route.dispatch(req.url, controller, next);\n  }\n\n  if (typeof fn === 'object') {\n    options = fn;\n    fn = options.action;\n  }\n\n  options = options || {};\n\n  if (typeof path === 'string' && path.charAt(0) !== '/') {\n    path = options.path ? options.path : '/' + path\n  }\n\n  // extend the route function with properties from this instance and its\n  // prototype.\n  _.extend(route, this);\n\n  // always good to have options\n  options = route.options = options || {};\n\n  // the main action function as well as any HTTP VERB action functions will go\n  // onto this stack.\n  route._actionStack = new MiddlewareStack;\n\n  // any before hooks will go onto this stack to make sure they get executed\n  // before the action stack.\n  route._beforeStack = new MiddlewareStack;\n  route._beforeStack.append(route.options.onBeforeAction);\n  route._beforeStack.append(route.options.before);\n\n  // after hooks get run after the action stack\n  route._afterStack = new MiddlewareStack;\n  route._afterStack.append(route.options.onAfterAction);\n  route._afterStack.append(route.options.after);\n\n\n  // track which methods this route uses\n  route._methods = {};\n\n  if (typeof fn === 'string') {\n    route._actionStack.push(path, _.extend(options, {\n      template: fn\n    }));\n  } else if (typeof fn === 'function' || typeof fn === 'object') {\n    route._actionStack.push(path, fn, options);\n  }\n\n  route._path = path;\n  return route;\n};\n\n/**\n * The name of the route is actually stored on the handler since a route is a\n * function that has an unassignable \"name\" property.\n */\nRoute.prototype.getName = function () {\n  return this.handler && this.handler.name;\n};\n\n/**\n * Returns an appropriate RouteController constructor the this Route.\n *\n * There are three possibilities:\n *\n *  1. controller option provided as a string on the route\n *  2. a controller in the global namespace with the converted name of the route\n *  3. a default RouteController\n *\n */\nRoute.prototype.findControllerConstructor = function () {\n  var self = this;\n\n  var resolve = function (name, opts) {\n    opts = opts || {};\n    var C = Iron.utils.resolve(name);\n    if (!C || !RouteController.prototype.isPrototypeOf(C.prototype)) {\n      if (opts.supressErrors !== true)\n        throw new Error(\"RouteController '\" + name + \"' is not defined.\");\n      else\n        return undefined;\n    } else {\n      return C;\n    }\n  };\n\n  var convert = function (name) {\n    return self.router.toControllerName(name);\n  };\n\n  var result;\n  var name = this.getName();\n\n  // the controller was set directly\n  if (typeof this.options.controller === 'function')\n    return this.options.controller;\n\n  // was the controller specified precisely by name? then resolve to an actual\n  // javascript constructor value\n  else if (typeof this.options.controller === 'string')\n    return resolve(this.options.controller);\n\n  // otherwise do we have a name? try to convert the name to a controller name\n  // and resolve it to a value\n  else if (name && (result = resolve(convert(name), {supressErrors: true})))\n    return result;\n\n  // otherwise just use an anonymous route controller\n  else\n    return RouteController;\n};\n\n\n/**\n * Create a new controller for the route.\n */\nRoute.prototype.createController = function (options) {\n  options = options || {};\n  var C = this.findControllerConstructor();\n  options.route = this;\n  var instance = new C(options);\n  return instance;\n};\n\nRoute.prototype.setControllerParams = function (controller, url) {\n};\n\n/**\n * Dispatch into the route's middleware stack.\n */\nRoute.prototype.dispatch = function (url, context, done) {\n  // call runRoute on the controller which will behave similarly to the previous\n  // version of IR.\n  assert(context._runRoute, \"context doesn't have a _runRoute method\");\n  return context._runRoute(this, url, done);\n};\n\n/**\n * Returns a relative path for the route.\n */\nRoute.prototype.path = function (params, options) {\n  return this.handler.resolve(params, options);\n};\n\n/**\n * Return a fully qualified url for the route, given a set of parmeters and\n * options like hash and query.\n */\nRoute.prototype.url = function (params, options) {\n  var path = this.path(params, options);\n  var host = (options && options.host) || Meteor.absoluteUrl();\n\n  if (host.charAt(host.length-1) === '/');\n    host = host.slice(0, host.length-1);\n  return host + path;\n};\n\n/**\n * Return a params object for the route given a path.\n */\nRoute.prototype.params = function (path) {\n  return this.handler.params(path);\n};\n\n/**\n * Add convenience methods for each HTTP verb.\n *\n * Example:\n *  var route = router.route('/item')\n *    .get(function () { })\n *    .post(function () { })\n *    .put(function () { })\n */\nHTTP_METHODS.forEach(function (method) {\n  Route.prototype[method] = function (fn) {\n    // track the method being used for OPTIONS requests.\n    this._methods[method] = true;\n\n    this._actionStack.push(this._path, fn, {\n      // give each method a unique name so it doesn't clash with the route's\n      // name in the action stack\n      name: this.getName() + '_' + method.toLowerCase(),\n      method: method,\n\n      // for now just make the handler where the same as the route, presumably a\n      // server route.\n      where: this.handler.where,\n      mount: false\n    });\n\n    return this;\n  };\n});\n\nIron.Route = Route;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar Url = Iron.Url;\nvar Layout = Iron.Layout;\nvar warn = Iron.utils.warn;\nvar assert = Iron.utils.assert;\n\nRouter = function (options) {\n  // keep the same api throughout which is:\n  // fn(url, context, done);\n  function router (req, res, next) {\n    //XXX this assumes no other routers on the parent stack which we should probably fix\n    router.dispatch(req.url, {\n      request: req,\n      response: res\n    }, next);\n  }\n\n  // the main router stack\n  router._stack = new MiddlewareStack;\n\n  // for storing global hooks like before, after, etc.\n  router._globalHooks = {};\n\n  // backward compat and quicker lookup of Route handlers vs. regular function\n  // handlers.\n  router.routes = [];\n\n  // to make sure we don't have more than one route per path\n  router.routes._byPath = {};\n\n  // always good to have options\n  this.configure.call(router, options);\n\n  // add proto properties to the router function\n  _.extend(router, this);\n\n  // let client and server side routing doing different things here\n  this.init.call(router, options);\n\n  Meteor.startup(function () {\n    Meteor.defer(function () {\n      if (router.options.autoStart !== false)\n        router.start();\n    });\n  });\n\n  return router;\n};\n\nRouter.prototype.init = function (options) {};\n\nRouter.prototype.configure = function (options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (value) {\n    if (!value)\n      return [];\n\n    if (_.isArray(value))\n      return value;\n\n    return [value];\n  };\n\n  // e.g. before: fn OR before: [fn1, fn2]\n  _.each(Iron.Router.HOOK_TYPES, function eachHookType (type) {\n    if (options[type]) {\n      _.each(toArray(options[type]), function eachHook (hook) {\n        self.addHook(type, hook);\n      });\n\n      delete options[type];\n    }\n  });\n\n  this.options = this.options || {};\n  _.extend(this.options, options);\n\n  return this;\n};\n\n/**\n * Just to support legacy calling. Doesn't really serve much purpose.\n */\nRouter.prototype.map = function (fn) {\n  return fn.call(this);\n};\n\n/*\n * XXX removing for now until this is thought about more carefully.\nRouter.prototype.use = function (path, fn, opts) {\n  if (typeof path === 'function') {\n    opts = fn || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, opts);\n  } else {\n    opts = opts || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, fn, opts);\n  }\n\n  return this;\n};\n*/\n\n//XXX seems like we could put a params method on the route directly and make it reactive\nRouter.prototype.route = function (path, fn, opts) {\n  var typeOf = function (val) { return Object.prototype.toString.call(val); };\n  assert(typeOf(path) === '[object String]' || typeOf(path) === '[object RegExp]', \"Router.route requires a path that is a string or regular expression.\");\n\n  if (typeof fn === 'object') {\n    opts = fn;\n    fn = opts.action;\n  }\n\n  var route = new Route(path, fn, opts);\n\n  opts = opts || {};\n\n  // don't mount the route\n  opts.mount = false;\n\n  // stack expects a function which is exactly what a new Route returns!\n  var handler = this._stack.push(path, route, opts);\n\n  handler.route = route;\n  route.handler = handler;\n  route.router = this;\n  \n  assert(!this.routes._byPath[handler.path],\n    \"A route for the path \" + JSON.stringify(handler.path) + \" already exists by the name of \" + JSON.stringify(handler.name) + \".\");\n  this.routes._byPath[handler.path] = route;\n\n  this.routes.push(route);\n\n  if (typeof handler.name === 'string')\n    this.routes[handler.name] = route;\n\n  return route;\n};\n\n/**\n * Find the first route for the given url and options.\n */\nRouter.prototype.findFirstRoute = function (url) {\n  for (var i = 0; i < this.routes.length; i++) {\n    if (this.routes[i].handler.test(url, {}))\n      return this.routes[i];\n  }\n\n  return null;\n};\n\nRouter.prototype.path = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.path for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.path(params, options);\n};\n\nRouter.prototype.url = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.url for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.url(params, options);\n};\n\n/**\n * Create a new controller for a dispatch.\n */\nRouter.prototype.createController = function (url, context) {\n  // see if there's a route for this url\n  var route = this.findFirstRoute(url);\n  var controller;\n\n  context = context || {};\n\n  if (route)\n    // let the route decide what controller to use\n    controller = route.createController({layout: this._layout});\n  else\n    // create an anonymous controller\n    controller = new RouteController({layout: this._layout});\n\n  controller.router = this;\n  controller.configureFromUrl(url, context, {reactive: false});\n  return controller;\n};\n\nRouter.prototype.setTemplateNameConverter = function (fn) {\n  this._templateNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.setControllerNameConverter = function (fn) {\n  this._controllerNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.toTemplateName = function (str) {\n  if (this._templateNameConverter)\n    return this._templateNameConverter(str);\n  else\n    return Iron.utils.classCase(str);\n};\n\nRouter.prototype.toControllerName = function (str) {\n  if (this._controllerNameConverter)\n    return this._controllerNameConverter(str);\n  else\n    return Iron.utils.classCase(str) + 'Controller';\n};\n\n/**\n *\n * Add a hook to all routes. The hooks will apply to all routes,\n * unless you name routes to include or exclude via `only` and `except` options\n *\n * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n * @param {Object} [options] Options to controll the hooks [optional]\n * @param {Function} [hook] Callback to run\n * @return {IronRouter}\n * @api public\n *\n */\n\nRouter.prototype.addHook = function(type, hook, options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (input) {\n    if (!input)\n      return [];\n    else if (_.isArray(input))\n      return input;\n    else\n      return [input];\n  }\n\n  if (options.only)\n    options.only = toArray(options.only);\n  if (options.except)\n    options.except = toArray(options.except);\n\n  var hooks = this._globalHooks[type] = this._globalHooks[type] || [];\n\n  var hookWithOptions = function () {\n    var thisArg = this;\n    var args = arguments;\n    // this allows us to bind hooks to options that get looked up when you call\n    // this.lookupOption from within the hook. And it looks better to keep\n    // plugin/hook related options close to their definitions instead of\n    // Router.configure. But we use a dynamic variable so we don't have to\n    // pass the options explicitly as an argument and plugin creators can\n    // just use this.lookupOption which will follow the proper lookup chain from\n    // \"this\", local options, dynamic variable options, route, router, etc.\n    return CurrentOptions.withValue(options, function () {\n      return self.lookupHook(hook).apply(thisArg, args);\n    });\n  };\n\n  hooks.push({options: options, hook: hookWithOptions});\n  return this;\n};\n\n/**\n * If the argument is a function return it directly. If it's a string, see if\n * there is a function in the Iron.Router.hooks namespace. Throw an error if we\n * can't find the hook.\n */\nRouter.prototype.lookupHook = function (nameOrFn) {\n  var fn = nameOrFn;\n\n  // if we already have a func just return it\n  if (_.isFunction(fn))\n    return fn;\n\n  // look up one of the out-of-box hooks like\n  // 'loaded or 'dataNotFound' if the nameOrFn is a\n  // string\n  if (_.isString(fn)) {\n    if (_.isFunction(Iron.Router.hooks[fn]))\n      return Iron.Router.hooks[fn];\n  }\n\n  // we couldn't find it so throw an error\n  throw new Error(\"No hook found named: \" + nameOrFn);\n};\n\n/**\n *\n * Fetch the list of global hooks that apply to the given route name.\n * Hooks are defined by the .addHook() function above.\n *\n * @param {String} [type] one of IronRouter.HOOK_TYPES\n * @param {String} [name] the name of the route we are interested in\n * @return {[Function]} [hooks] an array of hooks to run\n * @api public\n *\n */\n\nRouter.prototype.getHooks = function(type, name) {\n  var self = this;\n  var hooks = [];\n\n  _.each(this._globalHooks[type], function(hook) {\n    var options = hook.options;\n\n    if (options.except && _.include(options.except, name))\n      return [];\n\n    if (options.only && ! _.include(options.only, name))\n      return [];\n\n    hooks.push(hook.hook);\n  });\n\n  return hooks;\n};\n\nRouter.HOOK_TYPES = [\n  'onRun',\n  'onRerun',\n  'onBeforeAction',\n  'onAfterAction',\n  'onStop',\n\n  // not technically a hook but we'll use it\n  // in a similar way. This will cause waitOn\n  // to be added as a method to the Router and then\n  // it can be selectively applied to specific routes\n  'waitOn',\n\n  // legacy hook types but we'll let them slide\n  'load', // onRun\n  'before', // onBeforeAction\n  'after', // onAfterAction\n  'unload' // onStop\n];\n\n/**\n * A namespace for hooks keyed by name.\n */\nRouter.hooks = {};\n\n\n/**\n * A namespace for plugin functions keyed by name.\n */\nRouter.plugins = {};\n\n/**\n * Auto add helper mtehods for all the hooks.\n */\n\nRouter.HOOK_TYPES.forEach(function (type) {\n  Router.prototype[type] = function (hook, options) {\n    this.addHook(type, hook, options);\n  };\n});\n\n/**\n * Add a plugin to the router instance.\n */\nRouter.prototype.plugin = function (nameOrFn, options) {\n  var func;\n\n  if (typeof nameOrFn === 'function')\n    func = nameOrFn;\n  else if (typeof nameOrFn === 'string')\n    func = Iron.Router.plugins[nameOrFn];\n\n  if (!func)\n    throw new Error(\"No plugin found named \" + JSON.stringify(nameOrFn));\n\n  // fn(router, options)\n  func.call(this, this, options);\n\n  return this;\n};\n\nIron.Router = Router;\n","if (typeof Template !== 'undefined') {\n  /**\n   * The default anonymous loading template.\n   */\n  var defaultLoadingTemplate = new Template('DefaultLoadingTemplate', function () {\n    return 'Loading...';\n  });\n\n  /**\n   * The default anonymous data not found template.\n   */\n  var defaultDataNotFoundTemplate = new Template('DefaultDataNotFoundTemplate', function () {\n    return 'Data not found...';\n  });\n}\n\n/**\n * Automatically render a loading template into the main region if the\n * controller is not ready (i.e. this.ready() is false). If no loadingTemplate\n * is defined use some default text.\n */\n\nRouter.hooks.loading = function () {\n  // if we're ready just pass through\n  if (this.ready()) {\n    this.next();\n    return;\n  }\n\n  var template = this.lookupOption('loadingTemplate');\n  this.render(template || defaultLoadingTemplate);\n  this.renderRegions();\n};\n\n/**\n * Render a \"data not found\" template if a global data function returns a falsey\n * value\n */\nRouter.hooks.dataNotFound = function () {\n  if (!this.ready()) {\n    this.next();\n    return;\n  }\n\n  var data = this.lookupOption('data');\n  var dataValue;\n  var template = this.lookupOption('notFoundTemplate');\n\n  if (typeof data === 'function') {\n    if (!(dataValue = data.call(this))) {\n      this.render(template || defaultDataNotFoundTemplate);\n      this.renderRegions();\n      return;\n    }\n  }\n\n  // okay never mind just pass along now\n  this.next();\n};\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar warn = Iron.utils.warn;\nvar DynamicTemplate = Iron.DynamicTemplate;\nvar debug = Iron.utils.debug('iron:router <helpers>');\n\n/*****************************************************************************/\n/* UI Helpers */\n/*****************************************************************************/\n\n/**\n * Render the Router to a specific location on the page instead of the\n * document.body. \n */\nUI.registerHelper('Router', new Blaze.Template('Router', function () {\n  return Router.createView();\n}));\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('pathFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"pathFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  return path;\n});\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('urlFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n  var url = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"urlFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    url = route.url(data, {query: query, hash: hash});\n  }\n\n  return url;\n});\n\n/**\n * Create a link with optional content block.\n *\n * Example:\n *   {{#linkTo route=\"one\" query=\"query\" hash=\"hash\" class=\"my-cls\"}}\n *    <div>My Custom Link Content</div>\n *   {{/linkTo}}\n */\nUI.registerHelper('linkTo', new Blaze.Template('linkTo', function () {\n  var self = this;\n  var opts = DynamicTemplate.getInclusionArguments(this);\n\n  if (typeof opts !== 'object')\n    throw new Error(\"linkTo options must be key value pairs such as {{#linkTo route='my.route.name'}}. You passed: \" + JSON.stringify(opts));\n\n  opts = opts || {};\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = opts.route;\n  var data = _.extend({}, opts.data || DynamicTemplate.getParentDataContext(this));\n  var route = Router.routes[routeName];\n  var paramKeys;\n\n  warn(route, \"linkTo couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  // anything that isn't one of our keywords we'll assume is an attributed\n  // intended for the <a> tag\n  var attrs = _.omit(opts, 'route', 'query', 'hash', 'data');\n  attrs.href = path;\n\n  return Blaze.With(function () {\n    return DynamicTemplate.getParentDataContext(self);\n  }, function () {\n    return HTML.A(attrs, self.templateContentBlock);\n  });\n}));\n","var MiddlewareStack = Iron.MiddlewareStack;\nvar Url = Iron.Url;\nvar Layout = Iron.Layout;\nvar assert = Iron.utils.assert;\nvar DEFAULT_NOT_FOUND_TEMPLATE = '__IronRouterNotFound__';\nvar NO_ROUTES_TEMPLATE = '__IronRouterNoRoutes__';\n\n/**\n * Client specific initialization.\n */\nRouter.prototype.init = function (options) {\n  var self = this;\n\n  // the current RouteController from a dispatch\n  self._currentController = null;\n\n  // the current route\n  self._currentRoute = null;\n\n  // the current() dep\n  self._currentDep = new Deps.Dependency;\n\n  // the location computation\n  self._locationComputation = null;\n\n  // the ui layout for the router\n  self._layout = new Layout({template: self.options.layoutTemplate});\n\n  Meteor.startup(function () {\n    setTimeout(function maybeAutoInsertRouter () {\n      if (self.options.autoRender !== false)\n        self.insert({el: document.body});\n    });\n  });\n};\n\n/**\n * Programmatically insert the router into document.body or a particular\n * element with {el: 'selector'}\n */\nRouter.prototype.insert = function (options) {\n  this._layout.insert(options);\n  return this;\n};\n\n/**\n * Returns a layout view that can be used in a UI helper to render the router\n * to a particular place.\n */\nRouter.prototype.createView = function () {\n  return this._layout.create();\n};\n\nRouter.prototype.lookupNotFoundTemplate = function () {\n  if (this.options.notFoundTemplate)\n    return this.options.notFoundTemplate;\n  \n  return (this.routes.length === 0) ? NO_ROUTES_TEMPLATE : DEFAULT_NOT_FOUND_TEMPLATE;\n};\n\nRouter.prototype.lookupLayoutTemplate = function () {\n  return this.options.layoutTemplate;\n};\n\nRouter.prototype.dispatch = function (url, context, done) {\n  var self = this;\n\n  assert(typeof url === 'string', \"expected url string in router dispatch\");\n\n  var controller = this._currentController;\n  var route = this.findFirstRoute(url);\n  var prevRoute = this._currentRoute;\n\n  this._currentRoute = route;\n\n  //XXX Instead of this, let's consider making all RouteControllers\n  //    singletons that get configured at dispatch. Will revisit this\n  //    after v1.0.\n  if (controller && route && prevRoute === route) {\n    // this will change the parameters dep so anywhere you call\n    // this.getParams will rerun if the parameters have changed\n    controller.configureFromUrl(url, context);\n  } else {\n    // Looks like we're on a new route so we'll create a new\n    // controller from scratch.\n    controller = this.createController(url, context);\n  }\n\n  // even if we already have an existing controller we'll stop it\n  // and start it again. But since the actual controller instance\n  // hasn't changed, the helpers won't need to rerun.\n  if (this._currentController)\n    this._currentController.stop();\n\n  this._currentController = controller;\n\n  controller.dispatch(self._stack, url, function (err) {\n    if (err)\n      throw err;\n    else {\n      if (!controller.isHandled() && controller.willBeHandledOnServer()) {\n        window.location = controller.url;\n        return;\n      } else if (!controller.isHandled() && !controller.willBeHandledOnServer()) {\n        // looks like there's no handlers so let's give a default\n        // not found message! Use the layout defined in global config\n        // if we have one.\n        //\n        // NOTE: this => controller\n        this.layout(this.lookupOption('layoutTemplate'), {data: {url: this.url}});\n\n        var notFoundTemplate = this.lookupOption('notFoundTemplate');\n\n        if (!notFoundTemplate)\n          notFoundTemplate = (self.routes.length === 0) ? NO_ROUTES_TEMPLATE : DEFAULT_NOT_FOUND_TEMPLATE;\n        this.render(notFoundTemplate, {data: {url: this.url}});\n        this.renderRegions();\n        return;\n      } else {\n        return done && done(err);\n      }\n    }\n  });\n\n  // Note: even if the controller didn't actually change I change the\n  // currentDep since if we did a dispatch, the url changed and that\n  // means either we have a new controller OR the parameters for an\n  // existing controller have changed.\n  if (this._currentController == controller)\n    this._currentDep.changed();\n\n  return controller;\n};\n\n/**\n * The current controller object.\n */\nRouter.prototype.current = function () {\n  this._currentDep.depend();\n  return this._currentController;\n};\n\n/*\n * Scroll to a specific location on the page.\n * Overridable by applications that want to customize this behavior.\n */\nRouter.prototype._scrollToHash = function (hashValue) {\n  try {\n    var $target = $(hashValue);\n    $('html, body').scrollTop($target.offset().top);\n  } catch (e) {\n    // in case the hashValue is bogus just bail out\n  }\n};\n\n/**\n * Start reacting to location changes.\n */\nRouter.prototype.start = function () {\n  var self = this;\n  var prevLocation;\n\n  self._locationComputation = Deps.autorun(function locationComputation (c) {\n    var controller;\n    var loc = Iron.Location.get();\n    var hash, pathname, search;\n    var current = self._currentController;\n\n    if (!current || (prevLocation && prevLocation.path !== loc.path)) {\n      controller = self.dispatch(loc.href);\n\n      // if we're going to the server cancel the url change\n      if (controller.willBeHandledOnServer())\n        loc.cancelUrlChange();\n    } else {\n      self._scrollToHash(loc.hash);\n      // either the query or hash has changed so configure the current\n      // controller again.\n      current.configureFromUrl(loc.href);\n    }\n\n    prevLocation = loc;\n  });\n};\n\n/**\n * Stop all computations and put us in a not started state.\n */\nRouter.prototype.stop = function () {\n  if (!this._isStarted)\n    return;\n\n  if (this._locationComputation)\n    this._locationComputation.stop();\n\n  if (this._currentController)\n    this._currentController.stop();\n\n  this._isStarted = false;\n};\n\n/**\n * Go to a given path or route name, optinally pass parameters and options.\n *\n * Example:\n * router.go('itemsShowRoute', {_id: 5}, {hash: 'frag', query: 'string});\n */\nRouter.prototype.go = function (routeNameOrPath, params, options) {\n  var self = this;\n  var isPath = /^\\/|http/;\n  var path;\n\n  options = options || {};\n\n  if (isPath.test(routeNameOrPath)) {\n    // it's a path!\n    path = routeNameOrPath;\n  } else {\n    // it's a route name!\n    var route = self.routes[routeNameOrPath];\n    assert(route, \"No route found named \" + JSON.stringify(routeNameOrPath));\n    path = route.path(params, _.extend(options, {throwOnMissingParams: true}));\n  }\n\n  // let Iron Location handle it and we'll pick up the change in\n  // Iron.Location.get() computation.\n  Iron.Location.go(path, options);\n};\n","/**\n * Simple plugin wrapper around the loading hook.\n */\nRouter.plugins.loading = function (router, options) {\n  router.onBeforeAction('loading', options);\n};\n\n/**\n * Simple plugin wrapper around the dataNotFound hook.\n */\nRouter.plugins.dataNotFound = function (router, options) {\n  router.onBeforeAction('dataNotFound', options);\n};\n","Router = new Iron.Router;\n\nif (Meteor.isServer) {\n  Router.onBeforeAction(Iron.Router.bodyParser.json());\n}\n","\nTemplate.__checkName(\"__IronRouterNotFound__\");\nTemplate[\"__IronRouterNotFound__\"] = new Template(\"Template.__IronRouterNotFound__\", (function() {\n  var view = this;\n  return HTML.DIV({\n    style: \"width: 600px; margin: 0 auto; padding: 20px;\"\n  }, \"\\n    \", HTML.DIV({\n    style: \"font-size: 18pt; color: #999;\"\n  }, \"\\n      Oops, looks like there's no route on the client or the server for url: \\\"\", Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"url\"));\n  }), '.\"\\n    '), \"\\n  \");\n}));\n\nTemplate.__checkName(\"__IronRouterNoRoutes__\");\nTemplate[\"__IronRouterNoRoutes__\"] = new Template(\"Template.__IronRouterNoRoutes__\", (function() {\n  var view = this;\n  return HTML.Raw('<div style=\"font-family: helvetica; color: #777; max-width: 600px; margin: 20px auto;\">\\n      <h1 style=\"text-align: center; margin: 0; font-size: 48pt;\">\\n        iron:router\\n      </h1>\\n      <p style=\"text-align: center; font-size: 1.3em;\">\\n        Organize your Meteor application.\\n      </p>\\n      <div style=\"margin: 50px 0px;\">\\n        <pre style=\"background: #f2f2f2; margin: 0; padding: 10px;\">\\nRouter.route(\\'/\\', function () {\\n  this.render(\\'Home\\', {\\n    data: function () { return Items.findOne({_id: this.params._id}) }\\n  });\\n});\\n        </pre>\\n      </div>\\n      <div style=\"margin: 50px 0px;\">\\n        Check it out on Github:<br>\\n        <a href=\"https://github.com/eventedmind/iron-router\" target=\"_blank\">https://github.com/eventedmind/iron-router</a>\\n        <br>\\n        <br>\\n        And check out the new Guide:<br>\\n        <a href=\"https://eventedmind.github.io/iron-router\" target=\"_blank\">\\n          https://eventedmind.github.io/iron-router\\n        </a>\\n      </div>\\n    </div>');\n}));\n"]}