)]}'
{"version":3,"file":"/packages/gadicohen:famous-views.js","sources":["gadicohen:famous-views/lib/famous-views.js","gadicohen:famous-views/lib/meteorFamousView.js","gadicohen:famous-views/lib/sequencer.js","gadicohen:famous-views/lib/famous.js","gadicohen:famous-views/lib/famousEach.js","gadicohen:famous-views/lib/famousIf.js","gadicohen:famous-views/lib/famousContext.js","gadicohen:famous-views/lib/modifiers.js","gadicohen:famous-views/lib/views.js","gadicohen:famous-views/lib/views/_simple.js","gadicohen:famous-views/lib/views/ContainerSurface.js","gadicohen:famous-views/lib/views/EdgeSwapper.js","gadicohen:famous-views/lib/views/Flipper.js","gadicohen:famous-views/lib/views/HeaderFooterLayout.js","gadicohen:famous-views/lib/views/RenderController.js","gadicohen:famous-views/lib/views/Scrollview.js","gadicohen:famous-views/lib/views/Surface.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mB;;AAEA,0C;AACA,uD;;AAEA,iC;AACA,0D;;AAEA,W;;AAEA,oB;AACA,sC;AACA,8B;AACA,Y;AACA,sB;AACA,a;AACA,U;AACA,0B;AACA,U;AACA,oB;AACA,uB;AACA,E;AACA,C;AACA,+B;AACA,sB;AACA,oB;AACA,2B;AACA,yB;AACA,E;AACA,C;;AAEA,mC;AACA,iB;;AAEA,qE;AACA,0B;AACA,mB;AACA,G;;AAEA,4B;AACA,mE;AACA,0E;AACA,yB;;AAEA,mB;AACA,qB;AACA,oC;;AAEA,4C;AACA,qB;;AAEA,2B;AACA,6B;;AAEA,gE;AACA,mB;AACA,iC;AACA,yB;AACA,yB;AACA,qB;AACA,wE;AACA,sD;AACA,yD;;AAEA,sB;AACA,8B;AACA,U;AACA,kC;AACA,sE;AACA,gF;AACA,oC;AACA,mE;AACA,K;;AAEA,4B;AACA,uD;AACA,K;AACA,E;;AAEA,sB;;AAEA,yB;AACA,E;AACA,iC;AACA,mB;AACA,+C;AACA,yC;AACA,mB;AACA,kD;AACA,E;;AAEA,6C;AACA,qC;AACA,+E;AACA,kB;AACA,C;AACA,I;AACA,6B;AACA,yC;AACA,6E;AACA,qB;AACA,Y;AACA,2G;AACA,K;AACA,K;;AAEA,iC;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,mB;AACA,sB;AACA,gB;;AAEA,6C;AACA,Y;AACA,mD;AACA,6D;AACA,iE;AACA,oE;;AAEA,S;AACA,+B;AACA,K;AACA,iB;AACA,4D;AACA,qB;AACA,uB;AACA,K;;AAEA,wB;AACA,uC;AACA,6B;AACA,e;AACA,U;AACA,mC;AACA,wB;AACA,mB;AACA,kB;AACA,G;;AAEA,I;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,iB;AACA,kC;AACA,iB;AACA,0D;AACA,yC;AACA,+C;AACA,e;AACA,G;AACA,iC;AACA,8B;AACA,I;AACA,C;;AAEA,gC;AACA,e;AACA,yB;AACA,0B;AACA,0B;AACA,yC;AACA,Q;AACA,2B;AACA,G;AACA,iB;AACA,C;;AAEA,8B;;AAEA,0C;AACA,4C;AACA,iB;AACA,4C;AACA,a;AACA,C;AACA,+C;AACA,oB;AACA,uB;AACA,qD;AACA,a;AACA,C;AACA,6B;AACA,8C;AACA,C;;AAEA,S;;;;;;;;;;;;;;;;;;;;;AChMA,E;AACA,yE;AACA,qE;AACA,wE;AACA,6C;AACA,G;AACA,+E;AACA,G;;AAEA,2B;AACA,+B;;AAEA,wD;AACA,mD;AACA,oC;;AAEA,6B;AACA,qB;;AAEA,uC;;AAEA,Y;AACA,W;AACA,E;AACA,yB;AACA,sD;AACA,yE;;AAEA,uB;;AAEA,2E;AACA,6B;;AAEA,sE;AACA,C;;AAEA,gD;AACA,uB;AACA,c;AACA,gB;AACA,8B;AACA,mD;AACA,Y;AACA,C;;AAEA,qD;AACA,6B;AACA,+C;AACA,mB;AACA,C;;AAEA,E;AACA,yE;AACA,kE;AACA,sC;;AAEA,mD;AACA,wB;AACA,C;AACA,E;;AAEA,wD;AACA,+B;AACA,C;;AAEA,kE;AACA,mB;AACA,yE;AACA,yC;AACA,8E;;AAEA,oB;AACA,0B;;AAEA,M;AACA,6C;AACA,6D;AACA,+C;AACA,Q;AACA,4E;AACA,mC;AACA,+E;AACA,yE;AACA,M;;AAEA,wB;AACA,wB;;AAEA,iC;AACA,6D;AACA,a;AACA,K;AACA,G;;AAEA,2E;AACA,qB;AACA,iD;AACA,gD;;AAEA,2B;AACA,oB;AACA,oB;AACA,wB;AACA,sC;;AAEA,qE;AACA,8B;AACA,yB;AACA,8E;AACA,qC;AACA,Y;AACA,0B;AACA,wE;AACA,S;AACA,K;AACA,G;AACA,C;;AAEA,iD;AACA,sE;AACA,C;;AAEA,yC;AACA,+B;AACA,0B;AACA,6E;AACA,uC;AACA,C;;AAEA,sC;AACA,0C;AACA,8C;AACA,2D;AACA,6C;AACA,uE;AACA,4C;AACA,Q;AACA,0E;AACA,+C;AACA,G;AACA,C;;AAEA,2D;AACA,gD;AACA,yC;AACA,C;;AAEA,qE;AACA,6C;AACA,C;;AAEA,0D;AACA,+B;AACA,iC;AACA,C;;AAEA,2B;AACA,+B;AACA,C;;AAEA,8B;AACA,4C;AACA,2C;;AAEA,+C;AACA,sG;AACA,wC;AACA,C;;;;;;;;;;;;;;;;;;;ACvKA,iC;;AAEA,8B;AACA,sB;AACA,sB;;AAEA,e;AACA,yB;AACA,2C;AACA,8C;AACA,G;AACA,C;;AAEA,2C;AACA,6C;AACA,kC;;AAEA,qC;AACA,0B;AACA,oD;AACA,iE;AACA,iE;AACA,qD;AACA,kC;AACA,Q;AACA,kC;;AAEA,yC;AACA,e;AACA,C;;AAEA,E;AACA,4B;AACA,G;AACA,oE;AACA,2D;AACA,gC;AACA,G;;AAEA,4C;AACA,oB;AACA,wE;AACA,uE;AACA,4C;AACA,K;AACA,G;AACA,oC;AACA,C;;AAEA,wE;AACA,mB;AACA,kE;;AAEA,gD;AACA,mC;AACA,+D;;AAEA,mE;AACA,gD;;AAEA,yD;AACA,qE;AACA,0D;AACA,C;;AAEA,E;AACA,mF;AACA,sE;AACA,G;AACA,oE;AACA,Y;AACA,uD;AACA,yC;AACA,mC;AACA,C;;;;;;;;;;;;;;;;;;;AC1EA,0D;AACA,uD;AACA,sB;AACA,kE;AACA,4C;AACA,E;;AAEA,uC;AACA,mC;AACA,6C;AACA,2D;AACA,+B;AACA,mC;AACA,4C;AACA,wD;AACA,+C;AACA,Y;AACA,e;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,+B;AACA,mB;AACA,kC;;AAEA,gC;AACA,uF;AACA,qC;AACA,yB;AACA,yC;AACA,mD;AACA,Y;AACA,wC;AACA,K;;AAEA,iB;AACA,mC;AACA,U;AACA,kC;AACA,yB;AACA,uD;AACA,G;AACA,C;;AAEA,wE;AACA,6C;AACA,2D;;AAEA,e;AACA,0B;AACA,M;AACA,4B;AACA,yB;;AAEA,I;AACA,oB;AACA,iC;AACA,I;;AAEA,qC;;AAEA,kD;AACA,0C;;AAEA,e;AACA,iB;;AAEA,uD;AACA,+D;AACA,0D;AACA,wB;AACA,wF;;AAEA,0B;AACA,mB;AACA,sB;AACA,M;;AAEA,+B;AACA,6C;;AAEA,M;AACA,4D;AACA,oB;AACA,4C;AACA,mC;AACA,8B;AACA,kC;AACA,oC;AACA,U;AACA,mD;AACA,K;AACA,M;;AAEA,qD;AACA,uB;AACA,mD;AACA,8C;;AAEA,mB;AACA,oC;AACA,yB;AACA,K;AACA,K;AACA,C;;AAEA,yB;AACA,sC;AACA,wE;AACA,qC;AACA,wB;AACA,C;AACA,0C;AACA,yD;AACA,qC;AACA,wB;AACA,C;;AAEA,6C;AACA,8D;AACA,sC;AACA,oE;AACA,uD;AACA,wE;AACA,oD;AACA,oE;AACA,gD;AACA,wD;AACA,sC;AACA,+C;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,0B;AACA,4B;AACA,sE;;AAEA,8B;AACA,kC;AACA,yD;AACA,yD;AACA,U;;AAEA,c;AACA,+C;AACA,wC;AACA,uD;AACA,6B;AACA,oC;AACA,oD;AACA,G;;AAEA,0B;AACA,wF;AACA,6F;AACA,kD;;AAEA,0C;AACA,yC;;AAEA,yE;AACA,0B;AACA,kD;AACA,4C;AACA,6C;AACA,0B;AACA,uB;AACA,yD;AACA,6B;AACA,G;AACA,gF;;AAEA,gH;AACA,yC;;AAEA,yE;AACA,wE;;AAEA,uD;AACA,0D;AACA,4D;AACA,yB;AACA,qD;AACA,sC;AACA,8B;AACA,4B;AACA,U;AACA,kC;AACA,W;;AAEA,I;AACA,uC;AACA,0D;AACA,qD;AACA,wE;AACA,yC;AACA,sC;AACA,gD;AACA,Y;AACA,yB;AACA,K;AACA,2C;AACA,G;AACA,I;;AAEA,iB;;AAEA,0C;;AAEA,yC;AACA,6B;;AAEA,4B;AACA,uC;AACA,kD;AACA,K;;AAEA,G;;AAEA,2B;;AAEA,0D;AACA,iE;;AAEA,e;AACA,8C;AACA,wB;AACA,U;AACA,oC;;AAEA,mC;AACA,mC;;AAEA,oB;;AAEA,wB;AACA,sB;;AAEA,G;;AAEA,wC;AACA,kC;AACA,uD;;AAEA,qC;AACA,mD;AACA,8C;;;AAGA,mC;AACA,yC;AACA,uC;AACA,2B;AACA,iF;AACA,uD;AACA,8C;AACA,kC;AACA,4C;AACA,kB;AACA,0E;AACA,2C;AACA,U;AACA,kE;AACA,gD;AACA,G;;AAEA,I;AACA,0C;AACA,4E;AACA,+C;AACA,I;;AAEA,I;AACA,0C;AACA,4E;AACA,2B;AACA,I;;AAEA,mE;AACA,qD;AACA,I;AACA,oE;AACA,iB;AACA,6B;AACA,I;;AAEA,0C;AACA,mF;AACA,+B;;AAEA,oC;AACA,2C;AACA,2F;AACA,e;AACA,U;AACA,oE;AACA,yC;AACA,G;;AAEA,I;AACA,kC;AACA,+C;AACA,2C;AACA,I;;AAEA,6E;AACA,mE;;AAEA,4B;AACA,wB;AACA,yC;AACA,uE;AACA,oD;AACA,6B;AACA,mF;AACA,kC;AACA,sF;AACA,sF;AACA,4B;AACA,Q;AACA,8C;AACA,6B;AACA,O;;AAEA,I;AACA,2E;AACA,wE;AACA,yC;AACA,K;AACA,I;AACA,iB;AACA,uD;AACA,I;AACA,C;;AAEA,E;AACA,+D;AACA,uE;AACA,E;AACA,qE;AACA,kE;AACA,+D;AACA,yC;AACA,E;AACA,qE;AACA,iE;AACA,G;AACA,4B;AACA,gC;AACA,C;;AAEA,gE;;AAEA,gC;AACA,2C;AACA,gD;AACA,yB;AACA,wC;AACA,0C;AACA,gC;;AAEA,qB;AACA,kB;AACA,2B;AACA,4B;AACA,oC;AACA,oC;AACA,0E;AACA,iE;AACA,6C;AACA,O;AACA,K;;AAEA,M;AACA,mB;AACA,O;AACA,oE;AACA,mE;AACA,M;AACA,O;;AAEA,iD;;AAEA,4C;AACA,4B;AACA,wB;AACA,qC;AACA,qE;AACA,kC;AACA,8C;AACA,8E;AACA,qE;AACA,6C;AACA,2C;AACA,S;AACA,O;;AAEA,O;;AAEA,wB;AACA,iC;AACA,gB;AACA,G;AACA,E;;AAEA,iD;AACA,yC;AACA,6C;;;;;;;;;;;;;;;;;;;AC3ZA,wD;AACA,6B;AACA,wE;AACA,yE;;AAEA,uD;AACA,0C;AACA,gC;AACA,mC;AACA,0B;;AAEA,6D;AACA,mC;AACA,Q;AACA,2C;AACA,yC;AACA,yD;AACA,4C;AACA,a;;AAEA,Y;AACA,mF;AACA,+E;AACA,8C;AACA,a;AACA,+E;AACA,qD;AACA,6D;;AAEA,0C;AACA,4C;AACA,4C;;AAEA,gE;;AAEA,wD;AACA,yD;;AAEA,yD;AACA,4E;AACA,W;AACA,Q;AACA,6C;AACA,gD;AACA,gD;AACA,kC;AACA,Q;AACA,yD;AACA,yC;AACA,yD;AACA,W;AACA,Q;AACA,uD;AACA,yC;AACA,sD;AACA,4C;;AAEA,kD;AACA,4C;AACA,W;AACA,O;AACA,O;AACA,C;;AAEA,8B;AACA,4B;AACA,oE;;AAEA,qD;AACA,+D;AACA,sE;;AAEA,4B;AACA,iD;;AAEA,oD;AACA,qC;AACA,4E;AACA,sC;AACA,O;AACA,C;;AAEA,gC;AACA,gC;AACA,C;;AAEA,gE;;AAEA,oC;AACA,+C;AACA,gD;AACA,0D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,yD;AACA,iD;AACA,qD;;AAEA,E;AACA,wD;AACA,iD;AACA,gB;AACA,K;;AAEA,iC;AACA,yD;AACA,kC;AACA,qC;AACA,4B;;;AAGA,K;;AAEA,kB;AACA,C;AACA,+C;AACA,E;;;;;;;;;;;;;;;;;;ACvHA,E;AACA,8E;AACA,gF;AACA,+E;AACA,uE;AACA,G;;AAEA,kB;AACA,8D;AACA,kE;AACA,G;;AAEA,4B;AACA,4B;AACA,oE;;AAEA,mD;AACA,+D;AACA,sE;;AAEA,0B;AACA,iD;AACA,C;;AAEA,qC;AACA,yC;AACA,wC;AACA,uC;AACA,C;;AAEA,8B;AACA,gC;AACA,C;;AAEA,0D;AACA,sB;AACA,0C;;AAEA,yD;AACA,8B;AACA,+D;AACA,sE;;AAEA,6C;AACA,yD;AACA,yD;AACA,U;;AAEA,gD;AACA,gD;;AAEA,wD;AACA,6B;;AAEA,0B;AACA,kE;;AAEA,e;AACA,2E;AACA,G;;AAEA,qD;AACA,6C;AACA,iD;;;;;;;;;;;;;;;;;;;AC/DA,sB;AACA,yB;AACA,sD;AACA,wB;;AAEA,oB;AACA,oB;;AAEA,4G;AACA,kD;AACA,2B;AACA,uB;AACA,sB;AACA,I;;AAEA,uD;;AAEA,qC;AACA,wD;AACA,mC;;AAEA,6D;;AAEA,kC;AACA,mB;AACA,M;AACA,K;;AAEA,kD;AACA,+B;AACA,I;AACA,I;;;;;;;;;;;;;;;;;;;AC/BA,qB;;AAEA,iC;AACA,8C;AACA,C;;AAEA,4D;AACA,6B;AACA,qC;AACA,gC;AACA,c;AACA,wC;AACA,M;AACA,C;;AAEA,+B;;AAEA,2D;;AAEA,4C;AACA,+B;AACA,oC;AACA,sC;AACA,mB;AACA,K;AACA,K;;AAEA,2C;AACA,+B;AACA,oC;AACA,qC;AACA,mB;AACA,K;AACA,K;;AAEA,0D;AACA,2C;AACA,sD;AACA,4B;;AAEA,2B;AACA,Y;AACA,qD;AACA,kD;AACA,M;AACA,G;AACA,gC;AACA,6B;AACA,G;AACA,2E;;AAEA,iE;AACA,wE;AACA,uB;AACA,qF;AACA,wB;AACA,8B;AACA,O;AACA,4F;AACA,kC;;AAEA,mB;AACA,oE;AACA,yF;AACA,gB;;AAEA,qD;;AAEA,yB;AACA,8C;AACA,6D;AACA,gB;;AAEA,oD;AACA,wE;AACA,8B;AACA,iD;AACA,sD;AACA,iC;AACA,kE;AACA,8C;AACA,8C;AACA,sB;AACA,gB;;AAEA,mC;AACA,sD;AACA,kE;AACA,8C;AACA,oD;AACA,sB;AACA,gB;;AAEA,gD;AACA,sD;AACA,kE;AACA,8C;AACA,0D;AACA,sB;AACA,gB;;AAEA,uD;AACA,yE;AACA,wD;AACA,kE;AACA,8C;AACA,sD;AACA,sB;AACA,gB;AACA,O;AACA,K;AACA,K;;;AAGA,G;;AAEA,E;AACA,+D;AACA,6B;AACA,8B;AACA,mC;AACA,kB;AACA,6B;AACA,0B;AACA,K;AACA,E;;AAEA,kE;AACA,kD;AACA,E;AACA,E;;;;;;;;;;;;;;;;;;AClIA,iB;;AAEA,oE;AACA,8D;AACA,0D;AACA,uB;AACA,S;;AAEA,I;AACA,sC;AACA,kC;AACA,mB;AACA,I;;AAEA,+B;AACA,iE;AACA,8B;AACA,kC;AACA,kC;;AAEA,kB;AACA,+D;AACA,C;;AAEA,qE;AACA,2D;AACA,iC;AACA,kB;AACA,wB;AACA,mC;AACA,oD;AACA,wB;AACA,0E;AACA,8B;AACA,0E;AACA,8B;AACA,M;AACA,wE;AACA,6D;AACA,C;;;;;;;;;;;;;;;;;;;ACvCA,+B;AACA,uE;AACA,8C;AACA,G;;;;;;;;;;;;;;;;;;;ACHA,+B;AACA,2E;;AAEA,6C;AACA,8B;AACA,M;;AAEA,iE;AACA,yB;AACA,iD;AACA,2B;AACA,2C;AACA,G;;AAEA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACfA,+B;AACA,8D;AACA,6C;AACA,kB;AACA,qB;;AAEA,wB;AACA,yC;AACA,kC;;AAEA,gC;;AAEA,mB;AACA,iD;AACA,0B;AACA,iC;AACA,M;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACnBA,+B;AACA,sD;AACA,6C;AACA,qC;AACA,0D;AACA,gE;;AAEA,yB;AACA,oC;AACA,O;AACA,mC;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACbA,+B;AACA,4E;AACA,6C;AACA,qC;AACA,e;AACA,+F;AACA,sC;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACTA,qB;AACA,W;AACA,0C;AACA,gC;AACA,M;AACA,yC;AACA,gC;AACA,K;AACA,G;AACA,e;AACA,0C;AACA,yF;AACA,M;AACA,yC;AACA,6E;AACA,K;AACA,G;AACA,O;AACA,0C;AACA,iD;AACA,M;AACA,yC;AACA,2D;AACA,K;AACA,E;AACA,E;;AAEA,0E;AACA,kE;AACA,sC;AACA,oE;AACA,mE;AACA,E;;AAEA,+B;AACA,wE;AACA,6C;AACA,kB;AACA,qB;;AAEA,wB;AACA,yC;AACA,kC;;AAEA,6C;AACA,oB;AACA,6C;AACA,e;AACA,sB;AACA,gC;AACA,Y;AACA,mD;AACA,K;AACA,I;;AAEA,gC;;AAEA,mB;AACA,iD;AACA,0B;AACA,iC;AACA,M;AACA,I;;AAEA,+D;AACA,6B;AACA,wC;AACA,e;AACA,sB;AACA,gC;AACA,Y;AACA,mD;AACA,S;AACA,I;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;AC5EA,+B;AACA,4D;AACA,iC;AACA,mD;AACA,kD;AACA,oB;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACRA,+B;AACA,qD;;AAEA,6C;AACA,kC;;AAEA,oF;AACA,sD;AACA,8D;AACA,+E;AACA,mC;AACA,kF;;AAEA,iD;AACA,I;;AAEA,iE;AACA,kB;AACA,kB;AACA,2C;AACA,sE;AACA,kD;AACA,kD;AACA,a;AACA,wC;AACA,W;AACA,a;;AAEA,sB;AACA,wC;AACA,qC;AACA,gD;AACA,iF;AACA,4C;AACA,sC;AACA,gB;;AAEA,2B;AACA,yC;AACA,gB;AACA,M;AACA,K;;AAEA,I;AACA,G","sourcesContent":["var mainCtx = null;\n\n// Could use something from --settings too\nvar isDev = (\"localhost\" === window.location.hostname);\n\nlog = new Logger('famous-views');\nLogger.setLevel('famous-views', isDev ? 'trace' : 'info');\n\nFView = {};\n\nvar readyQueue = [];\nvar readyDep = new Tracker.Dependency;\nFView.ready = function(func) {\n\tif (func) {\n    if (FView.isReady)\n      func();\n    else  \n\t\t  readyQueue.push(func);\n  } else {\n\t\treadyDep.depend();\n\t\treturn FView.isReady;\n\t}\n}\nFView.runReadies = function() {\n\tFView.isReady = true;\n\treadyDep.changed();\n\twhile(readyQueue.length) {\n\t\t(readyQueue.shift())();\n\t}\n}\n\n// famous-views globals from Famous\nTransform = null;\n\nif (typeof(famous) === 'undefined' && typeof(define) !== 'undefined')\ndefine(function(require) {\n//  console.log(1);\n});\n\nFView.startup = function() {\n  log.debug('Current logging default is \"debug\" (for localhost).  '\n    + 'Change in your app with Logger.setLevel(\"famous-views\", \"info\");');\n  FView.startedUp = true;\n\n  famous.polyfills;\n  famous.core.famous;\n  Transform = famous.core.Transform;\n\n  // Note, various views are registered here\n  FView.runReadies();\n\n  // Required document.body\n  Meteor.startup(function() {\n\n    // Sanity check, disallow templates with same name as a View\n    var names = [];\n    for (var name in FView.views)\n      if (Template[name])\n        names.push(name);\n    if (names.length)\n      throw new Error(\"You have created Template(s) with the same name \"\n        + \"as these famous-views: \" + names.join(', ')\n        + '.  Nothing will work until you rename them.');\n\n    if (FView.mainCtx)\n      mainCtx = FView.mainCtx;\n    else {\n      if (FView.mainCtx !== false)\n        log.debug('Creating a new main context.  If you already have '\n          + 'your own, set FView.mainCtx = yourMainContext (or to false to get '\n          + 'rid of this warning)');\n      FView.mainCtx = mainCtx = famous.core.Engine.createContext();\n    }\n\n    if (Template.famousInit)\n      Blaze.render(Template.famousInit, document.body);\n  });\n};\n\nFView.isReady = false;\n\n// Imports from weak deps\n/*\nif (Package['mjnetworks:famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:famous'].famous;\nelse if (Package['mjnetworks:mj-famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:mj-famous'].famous;\n*/\n\n// Load as ealry as possible, and keep trying\nif (typeof(famous) !== 'undefined') {\n  log.debug(\"Starting up.  famous global found while loading package, great!\");\n  FView.startup();\n}\nelse\n  Meteor.startup(function() {\n    if (typeof(famous) !== 'undefined') {\n      log.debug(\"Starting up.  famous global found during Meteor.startup()\");\n    \tFView.startup();\n    } else {\n      log.debug(\"No famous global available in Meteor.startup().  Call FView.startup() when appropriate.\");\n    }\n  });\n\noptionString = function(string) {\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;  \n  if (string === null)\n    return null;\n\n  if (string[0] == '[' || string[0] == '{') {\n    var obj;\n    string = string.replace(/\\bauto\\b/g, '\"auto\"');\n    string = string.replace(/undefined/g, '\"__undefined__\"');\n    // JSON can't parse values like \".5\" so convert them to \"0.5\"\n    string = string.replace(/([\\[\\{,]+)(\\W*)(\\.[0-9])/g, '$1$20$3');\n\n    try {\n      obj = JSON.parse(string);\n    }\n    catch (err) {\n      log.error(\"Couldn't parse JSON, skipping: \" + string);\n      log.error(err);\n      return undefined;\n    }\n\n    for (var key in obj)\n      if (obj[key] === '__undefined__')\n        obj[key] = undefined;\n    return obj;\n  } else {\n    var float = parseFloat(string);\n    if (!_.isNaN(float))\n      return float;\n    return string;\n  }\n\n  /*\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;\n  if (string.substr(0,1) == '[') {\n    var out = [];\n    string = string.substr(1, string.length-2).split(',');\n    for (var i=0; i < string.length; i++)\n      out.push(optionString(string[i].trim()));\n    return out;\n  }\n  if (string.match(/^[0-9\\.]+$/))\n    return parseFloat(string);\n  */\n}\n\nhandleOptions = function(data) {\n  options = {};\n  for (var key in data) {\n    var value = data[key];\n    if (_.isString(value))\n      options[key] = optionString(value);\n    else\n      options[key] = value;\n  }\n  return options;\n}\n\n/* --- totally not done --- */\n\nFView.showTreeGet = function(renderNode) {\n  var obj = renderNode._node._child._object;\n    if (obj.node)\n      obj.node = this.showTreeGet(obj.node);\n  return obj;\n}\nFView.showTreeChildren = function(renderNode) {\n  var out = {}, i=0;\n  if (renderNode._node)\n    out['child'+(i++)] = this.showTreeGet(renderNode)\n  return out;\n}\nFView.showTree = function() {\n  console.log(this.showTreeChildren(mainCtx));\n}\n\n/* --- */\n\n\n","/*\n * Templates are always added to a MeteorFamousView (\"fview\"), in turn is\n * added to it's parent fview or a context.  This allows us to handle\n * situations where a template is later removed (since nodes cannot ever\n * be manually removed from the render tree).\n * \n * http://stackoverflow.com/questions/23087980/how-to-remove-nodes-from-the-ren\n */\n\nvar meteorFamousViews = {};\nvar meteorFamousViewsCount = 0;\n\nMeteorFamousView = function(blazeView, options, noAdd) {\n  this.id = options.id || ++meteorFamousViewsCount;\n  meteorFamousViews[this.id] = this;\n\n  this.blazeView = blazeView;\n  this.children = [];\n\n  // this._callbacks = { destroy: [] };\n\n  if (noAdd)\n    return;\n  \n  var parent = blazeView;\n  while ((parent=parent.parentView) && !parent.fview);\n  parent = parent ? parent.fview : { node: FView.mainCtx, children: [] };\n\n  this.parent = parent;\n\n  // Keep track of fview children, since Meteor only tracks children in DOM\n  parent.children.push(this);\n\n  // Adding to famous parent node, once done here, is now in famous.js\n}\n\nMeteorFamousView.prototype.render = function() {\n  if (this.isDestroyed)\n    return [];\n  if (this.node)\n    return this.node.render();\n  console.log('render called before anything set');\n  return [];\n}\n\nMeteorFamousView.prototype.setNode = function(node) {\n  // surface or modifier/view\n  this.node = new famous.core.RenderNode(node);\n  return this.node;\n}\n\n/*\n  Replace fview.onDestroy = function() with fview.on('destroy', function)\n  which can be called multiple times.  The old way will still work\n  but will show a deprecation warning.\n\nMeteorFamousView.prototype.onDestroy = function() {\n  return '__original__';\n}\n*/\n\nMeteorFamousView.prototype.preventDestroy = function() {\n\tthis.destroyPrevented = true;\t\n}\n\nMeteorFamousView.prototype.destroy = function(isTemplateDestroy) {\n  var fview = this;\n  log.debug('Destroying ' + (fview._view ? fview._view.name : fview.kind)\n    + ' (#' + fview.id + ') and children'\n    + (isTemplateDestroy&&fview.destroyPrevented ? ' (destroyPrevented)':''));\n\n  // XXX ADD TO DOCS\n  if (isTemplateDestroy) {\n\n    /*\n    if (fview.onDestroy() === '__original__')\n      for (var i=0; i < fview._callbacks.destroy.length; i++)\n        fview._calbacks.destroy[i].call(fview);\n    else\n      log.warn('#' + fview.id + ' - you set fview.onDestroy = function().  '\n        + 'This will work for now '\n        + 'but is deprecated.  Please use fview.onDestoy(callback), which may '\n        + 'be used multiple times, and receives the `fview` as `this`.');\n    */\n\n    if (fview.onDestroy)\n      fview.onDestroy();\n\n    if (fview.destroyPrevented) {\n      // log.debug('  #' + fview.id + ' - destroyPrevented');\n      return;\n    }\n  }\n\n  // First delete children (via Blaze to trigger Template destroy callback)\n  if (fview.children)\n    for (var i=0; i < fview.children.length; i++)\n      Blaze.remove(fview.children[i].blazeView);\n\n  fview.isDestroyed = true;\n  fview.node = null;\n  fview.view = null;\n  fview.modifier = null;\n  delete(meteorFamousViews[fview.id]);\n\n  // If we're part of a sequence, now is the time to remove ourselves\n  if (fview.parent.sequence) {\n    if (fview.sequence) {\n      // TODO, we're a child sequence, remove the child (TODO in sequencer.js)\n      // log.debug(\"child sequence\");\n    } else {\n      _.defer(function() {\n        fview.parent.sequence.remove(fview);  // less flicker in a defer\n      });\n    }\n  }\n}\n\nMeteorFamousView.prototype.getSize = function() {\n  return this.node && this.node.getSize() || this.size || [true,true];\n}\n\nthrowError = function(startStr, object) {\n  if (object instanceof Object)\n    console.error(object);\n  throw new Error('FView.getData() expects BlazeView or TemplateInstance or '\n      + 'DOM node, but got ' + object);\n}\n\nFView.from = function(viewOrTplorEl) {\n  if (viewOrTplorEl instanceof Blaze.View)\n    return FView.fromBlazeView(viewOrTplorEl);\n  else if (viewOrTplorEl instanceof Blaze.TemplateInstance)\n    return FView.fromTemplate(viewOrTplorEl);\n  else if (viewOrTplorEl && typeof viewOrTplorEl.nodeType === 'number')\n    return FView.fromElement(viewOrTplorEl);\n  else {\n    throwError('FView.getData() expects BlazeView or TemplateInstance or '\n        + 'DOM node, but got ', viewOrTplorEl);\n  }\n}\n\nFView.fromBlazeView = FView.dataFromView = function(view) {\n  while ((view=view.parentView) && !view.fview);\n  return view ? view.fview : undefined;  \n}\n\nFView.fromTemplate = FView.dataFromTemplate = function(tplInstance) {\n  return this.dataFromView(tplInstance.view);\n}\n\nFView.fromElement = FView.dataFromElement = function(el) {\n  var view = Blaze.getView(el);\n  return this.dataFromView(view);\n}\n\nFView.byId = function(id) {\n  return meteorFamousViews[id];\n}\n\n// Leave as alias?  Deprecate?\nFView.dataFromCmp = FView.dataFromComponent;\nFView.dataFromTpl = FView.dataFromTemplate;\n\nFView.dataFromComponent = function(component) {\n  log.warn(\"FView.dataFromComponent has been deprecated.  Please use 'FView.fromBlazeView' instead.\");\n  return FView.fromBlazeView(component);\n}\n","/* Sequencer and childSequence */\n\nsequencer = function(parent) {\n  this._sequence = [];\n  this._children = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.childNo = parent._children.length;\n    this.startIndex = parent._sequence.length;\n  }\n}\n\n// TODO, refactor + cleanup for constructor\nsequencer.prototype.child = function(index) {\n  var child = new sequencer(this);\n\n  if (typeof index !== 'undefined') {\n    child.childNo = index;\n    child.startIndex = index < this._children.length\n      ? this._children[index].startIndex : this._sequence.length;\n    // Recall for below loop that child has not been inserted yet\n    for (var i=index; i < this._children.length; i++)\n      this._children[i].childNo++;\n  } else\n    index = this._children.length;\n\n  this._children.splice(index, 0, child);\n  return child;\n}\n\n/*\n * For both functions below:\n * \n *   1. Splice into correct position in parent sequencer's _sequence\n *   2. Update the startIndex of all siblings born after us\n *   3. Modify our own _sequence\n */\n\nsequencer.prototype.push = function(value) {\n  if (this.parent) {\n    this.parent.splice(this.startIndex+this._sequence.length, 0, value);\n    for (var i=this.childNo+1; i < this.parent._children.length; i++) {\n      this.parent._children[i].startIndex++;\n    }\n  }\n  return this._sequence.push(value);\n}\n\nsequencer.prototype.splice = function(index, howMany /*, arguments */) {\n  if (!this.parent)\n    return this._sequence.splice.apply(this._sequence, arguments);\n\n  var diff, max = this._sequence.length - index;\n  if (howMany > max) howMany = max;\n  diff = (arguments.length - 2) - howMany; // inserts - howMany\n\n  for (var i=this.childNo+1; i < this.parent._children.length; i++)\n    this.parent._children[i].startIndex += diff;\n\n  this._sequence.splice.apply(this._sequence, arguments);\n  arguments[0] += this.startIndex;  // add startIndex and re-use args\n  return this.parent.splice.apply(this.parent, arguments);\n}\n\n/*\n * Currently we don't keep track of our children and descedent children separately,\n * so grandChild.push(x) && parent.remove(x) would break everything :)\n */\nsequencer.prototype.remove = function(value /*, suspectedIndex */) {\n  var index;\n  for (index=0; index < this._sequence.length; index++)\n    if (this._sequence[index] === value) \n      return this.splice(index, 1);\n}\n","/* Extend Meteor Template framework for .famousEvents() */\nTemplate.prototype.famousEvents = function (eventMap) {\n  var template = this;\n  template.__famousEventMaps = (template.__famousEventMaps || []);\n  template.__famousEventMaps.push(eventMap);\n};\n\nfunction setupEvents(fview, template) {\n  if (template.__famousEventMaps) {\n    var target = fview.surface || fview.view;\n    _.each(template.__famousEventMaps, function(eventMap) {\n      for (var k in eventMap) {\n        target.on(k, (function(k) {\n          return function(/* arguments */) {\n            Array.prototype.push.call(arguments, fview);\n            eventMap[k].apply(this, arguments);\n          };\n        })(k));\n      }\n    });\n  }\n}\n\nfunction autoHeight(callback) {\n  var fview = this;\n  var div = fview.surface.content;\n\n  var height = div.scrollHeight;\n  if (height && (!fview.size || (fview.size.length == 2 && fview.size[1] != height))) {\n    fview.size = [undefined, height];\n    if (fview.modifier) {\n      fview.modifier.setSize(fview.size);\n      fview.surface.setSize([undefined,undefined]);\n    } else {\n      fview.surface.setSize(fview.size);\n    }\n\n    if (callback)\n      callback.call(fview, height);\n  } else {\n    window.setTimeout(function() {\n      fview.autoHeight();\n    }, 10);  // FYI: 16.67ms = 1x 60fps animation frame\n  }\n}\n\nfunction templateSurface(div, fview, renderedTemplate, tName, options) {\n  // var div = document.createElement('div');\n  var autoSize = options.size && options.size[1] == 'auto';\n\n  if (autoSize)\n    options.size = [0, 0];\n  else\n    div.style.height='100%';\n  div.style.width='100%';\n\n  /*\n  if (fview.uiHooks)\n    div._uihooks = fview.uiHooks;\n  */\n\n//  UI.insert(renderedTemplate, div);\n\n//  we're now forced to always render in main func\n//  renderedTemplate.domrange.attach(div);\n\n  if (!options)\n    options = {};\n\n  // If any HTML was generated, create a surface for it\n  if (options.view=='Surface' || div.innerHTML.trim().length) {\n    fview.surfaceClassName = 't_'+tName.replace(/ /, '_');\n    if (options.classes)\n      throw new Error('Surface classes=\"x,y\" is deprecated.  Use class=\"x y\" instead.');\n\n    var surfaceOptions = {\n      content: div,\n      size: fview.size\n    };\n\n    fview.surface = fview.view;\n    fview.surface.setOptions(surfaceOptions);\n\n    /*\n    fview.surface = new famous.core.Surface(surfaceOptions);\n    if (!fview.node)\n      // nothing, i.e. Surface & no modifier\n      fview.setNode(fview.surface);\n    else if (!fview.sequencer)\n      // add Surface as only child\n      fview.node.add(fview.surface);\n    else {\n      fview.sequencer.sequence.push(fview.surface);\n    }\n    */\n\n    var pipeChildrenTo = fview.parent.pipeChildrenTo;\n    if (pipeChildrenTo)\n      for (var i=0; i < pipeChildrenTo.length; i++)\n        fview.surface.pipe(pipeChildrenTo[i]);\n\n    if (autoSize) {\n      fview.autoHeight = autoHeight;\n      fview.autoHeight();\n    }\n  }  \n}\n\n// Used by famousEach too\nparentViewName = function(blazeView) {\n  while (blazeView.name == \"with\" || blazeView.name == \"(contentBlock)\")\n    blazeView = blazeView.parentView;\n  return blazeView.name;\n}\nparentTemplateName = function(blazeView) {\n  while (blazeView && !blazeView.name.match(/^Template/))\n    blazeView = blazeView.parentView;\n  return blazeView.name;\n}\n\n// Need to fire manually at appropriate time,\n// for non-Surfaces which are never added to the DOM by meteor\nrunRenderedCallback = function(view) {\n//  if (view._callbacks.rendered && view._callbacks.rendered.length)\n  var needsRenderedCallback = true; // uh yeah, TODO :>\n  view.domrange = null; // TODO, check if it's a surface / real domrange\n  if (needsRenderedCallback && ! view.isDestroyed &&\n      view._callbacks.rendered && view._callbacks.rendered.length) {\n    Tracker.afterFlush(function callRendered() {\n      if (needsRenderedCallback && ! view.isDestroyed) {\n        needsRenderedCallback = false;\n        Blaze._fireCallbacks(view, 'rendered');\n      }\n    });\n  }\n}\n\nfunction famousCreated() {\n  var blazeView = this.view;\n  var famousViewName = blazeView.name ? blazeView.name.substr(7) : \"\";\n\n  this.data = this.data || {};\n  var dataContext = this.data.data\n    || Blaze._parentData(1) && Blaze._parentData(1, true)\n    || Blaze._parentData(0) && Blaze._parentData(0, true)\n    || {};\n\n  // deprecate\n  if (!this.data.view && famousViewName === \"\")\n    this.data.view = 'SequentialLayout';\n  if (!this.data.view) this.data.view = famousViewName;\n  else if (!famousViewName) {\n    famousViewName = this.data.view;\n    blazeView.viewName = 'Famous.' + famousViewName;\n  }\n\n  // Deprecated 2014-08-17\n  if (this.data.size && _.isString(this.data.size) && this.data.size.substr(0,1) != '[')\n    throw new Error('[famous-views] size=\"' + this.data.size + '\" is deprecated, please use '\n      + 'size=\"['+ this.data.size + ']\" instead');\n\n  // See attribute parsing notes in README\n  var options = handleOptions(this.data);\n\n  // These require special handling (but should still be moved elsewhere)\n  if (this.data.direction)\n    options.direction = this.data.direction == \"Y\"\n      ? famous.utilities.Utility.Direction.Y\n      : famous.utilities.Utility.Direction.X;\n  if (options.translate) {\n    options.transform =\n      Transform.translate.apply(null, options.translate);\n    delete options.translate;\n  }\n  // any other transforms added here later must act on existing transform matrix\n\n  if (!this.data.modifier && (this.data.origin || this.data.size || this.data.translate || this.data.transform))\n    this.data.modifier = 'StateModifier';\n\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, options);\n  fview._view = FView.views[this.data.view] || { name: this.data.view };\n\n  var pViewName = parentViewName(blazeView.parentView);\n  var pTplName = parentTemplateName(blazeView.parentView);\n  log.debug('New ' + famousViewName + \" (#\" + fview.id + ')'\n    + (this.data.template\n      ? ', content from \"' + this.data.template + '\"'\n      : ', content from inline block')\n    + ' (parent: ' + pViewName\n    + (pViewName == pTplName\n      ? ''\n      : ', template: ' + pTplName)\n    + ')');\n\n  /*\n  if (FView.viewOptions[this.data.view]\n      && FView.viewOptions[this.data.view].childUiHooks) {\n    // if childUiHooks specified, store them here too\n    fview.childUiHooks = FView.viewOptions[this.data.view].childUiHooks;\n  } else if (fview.parent.childUiHooks) {\n    if (this.data.view == 'Surface') {\n      fview.uiHooks = fview.parent.childUiHooks;\n    } else {\n      // Track descedents\n    }\n    console.log('child ' + this.data.view);\n  }\n  */\n\n  var view, node;\n\n  if (this.data.view /* != 'Surface' */) {\n\n    view = FView.getView(this.data.view);\n    node = new view(options);\n\n    if (node.sequenceFrom) {\n      fview.sequence = new sequencer();\n      node.sequenceFrom(fview.sequence._sequence);\n    }\n\n  }\n\n  if (this.data.modifier) {\n\n    fview._modifier = FView.modifiers[this.data.modifier];\n    fview.modifier = fview._modifier.create.call(fview, options);\n\n    if (node) {\n      fview.setNode(fview.modifier).add(node);\n      fview.view = node;\n    } else\n      fview.setNode(fview.modifier);\n\n    if (fview._modifier.postRender)\n      fview._modifier.postRender();\n\n  } else if (node) {\n\n    fview.setNode(node);\n    fview.view = node;\n\n  }\n\n  // could do pipe=1 in template helper?\n  if (fview.parent.pipeChildrenTo)\n    fview.pipeChildrenTo = fview.parent.pipeChildrenTo;\n\n  // think about what else this needs\n  if (fview._view && fview._view.famousCreatedPost)\n    fview._view.famousCreatedPost.call(fview);\n\n\n  // Render contents (and children)\n  var newBlazeView, template, scopedView;\n  if (blazeView.templateContentBlock) {\n    if (this.data.template)\n      throw new Error(\"A block helper {{#View}} cannot also specify template=X\");\n    // Called like {{#famous}}inlineContents{{/famous}}\n    template = blazeView.templateContentBlock;\n  } else if (this.data.template) {\n    template = Template[this.data.template];\n    if (!template)\n      throw new Error('Famous called with template=\"' + this.data.template\n        + '\" but no such template exists');\n  } else {\n    // Called with inclusion operator but not template {{>famous}}\n    throw new Error(\"No template='' specified\");\n  }\n\n  /*\n  newBlazeView = template.constructView();\n  scopedView = Blaze.With(dataContext, function() { return newBlazeView; });\n  Blaze.materializeView(scopedView, blazeView);\n  */\n\n  /*\n  newBlazeView = Blaze.render(function() {\n    Blaze.With(dataContext, function() { return template.constructView(); })\n  }, div, null, blazeView);\n  */\n\n  // Avoid Blaze running rendered() before it's actually on the DOM\n  // Delete must happen before Blaze.render() called.\n  /*\n  var onRendered = this.data.view == 'Surface' && template.rendered;\n  if (onRendered)\n    delete template.rendered;\n  */\n\n  var div = document.createElement('div');\n  newBlazeView = Blaze.renderWithData(template, dataContext, div, null, blazeView);\n  setupEvents(fview, template);\n\n  if (this.data.view == 'Surface') {\n    templateSurface(div, fview, scopedView,\n      this.data.template || parentTemplateName(blazeView.parentView).substr(9) + '_inline',\n      options);\n  } else {\n    // no longer necessary since we're forced to render to a div now\n    // runRenderedCallback(newBlazeView);\n  }\n\n  /*\n  var template = options.template;\n  if (template && Template[template].beforeAdd)\n  \tTemplate[template].beforeAdd.call(this);\n  */\n\n  /* This is the final step where the fview is added to Famous Render Tree */\n  /* By deferring the actual add we can prevent a little flicker */\n\n  var parent = fview.parent;\n//  _.defer(function() {\n    if (parent._view && parent._view.add)\n      // views can explicitly handle how their children should be added\n      parent._view.add.call(parent, fview, options);\n    else if (parent.sequence)\n      // 'sequence' can be an array, sequencer or childSequencer, it doesn't matter\n      parent.sequence.push(fview);\n    else if (!parent.node || (parent.node._object && parent.node._object.isDestroyed))\n      // compView->compView.  long part above is temp hack for template rerender #2010\n      parent.setNode(fview);\n    else\n      // default case, just use the add method\n      parent.node.add(fview);\n // });\n\n  /*\n   * Now that the Template has been rendered to the Famous Render Tree (and\n   * also to the DOM in the case of a Surface), let's run any rendered()\n   * callback that may have been defined.\n   */\n  /*\n  if (onRendered)\n    onRendered.call(fview.blazeView._templateInstance);\n  */\n}\n\n/*\n * This is called by Blaze when the View/Template is destroyed,\n * e.g. {{#if 0}}{{#Scrollview}}{{/if}}.  When this happens we need to:\n *\n * 1) Destroy children (Blaze won't do it since it's not in the DOM),\n *    and any \"eaches\" that may have been added from a famousEach.\n * 2) Call fview.destroy() which handles cleanup w.r.t. famous,\n *    which lives in meteorFamousView.js.\n *\n * It's possible we want to have the \"template\" destroyed but not the\n * fview in the render tree to do a graceful exit animation, etc.\n */\nfunction famousDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousView = new Template(\n  'famous',           // viewName: \"famous\"\n  function() {        // Blaze.View \"renderFunc\"\n    var blazeView = this;\n    var data = Blaze.getData(blazeView);\n    var tpl = blazeView._templateInstance;\n    var fview = blazeView.fview;\n\n    var changed = {};\n    var orig = {};\n    for (var key in data) {\n      var value = data[key];\n      if (typeof value === \"string\")\n        value = optionString(value);\n      if (!EJSON.equals(value, tpl.data[key]) || !blazeView.hasRendered) {\n        orig[key] = blazeView.hasRendered ? tpl.data[key] : null;\n        changed[key] = tpl.data[key] = value;\n      }\n    }\n\n    /*\n     * Think about:\n     * \n     * 1) Should the function get the old value or all old data too?\n     * 2) Should the function get all the new data, but translated?\n     *\n     */\n\n    _.each(['modifier', 'view'], function(node) {\n\n      // If the fview has a modifier or view\n      var what = '_' + node;\n      if (fview[what]) {\n        if (fview[what].attrUpdate) {\n          // If that mod/view wants to finely handle reactive updates\n          for (var key in changed)\n            fview[what].attrUpdate.call(fview,\n              key, changed[key], orig[key], tpl.data, !blazeView.hasRendered);\n        } else if (fview[node].setOptions && blazeView.hasRendered) {\n          // Otherwise if it has a setOptions\n          fview[node].setOptions(tpl.data);\n        }\n      }\n\n    });\n\n//    console.log(view);\n    blazeView.hasRendered = true;\n    return null;\n  }\n);\n\nBlaze.registerHelper('famous', FView.famousView);\nFView.famousView.created = famousCreated;\nFView.famousView.destroyed = famousDestroyed;\n","function famousEachRender(eachView, template, argFunc) {\n  var fview = eachView.fview;\n  var sequence = fview.sequence;\t\t\t\t    // fviews for Famous Render Tree\n  var children = fview.children = [];\t      // each contentBlock instance\n\n  // For Blaze.currentView (see blaze/builtins.js#each)\n  eachView.argVar = new Blaze.ReactiveVar;\n  eachView.autorun(function () {\n    eachView.argVar.set(argFunc());\n  }, eachView.parentView);\n\n  eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          var newItemView = Blaze.With(item, function() {\n            return template.constructView();\n          });\n\n          /*\n           * This is the repeated block inside famousEach, but not the actual node/\n           * view/surface that gets created on render as this block's children.\n           * We create a pseudo-fview for this\n           */\n          newItemView.fview = new MeteorFamousView(null, {}, true /* noAdd */);\n          newItemView.fview.kind = 'famousEachBlock';\n          newItemView.fview.sequence = sequence.child(index);\n\n          if (fview.parent.pipeChildrenTo)\n            newItemView.fview.pipeChildrenTo\n              = fview.parent.pipeChildrenTo;\n\n          children.splice(index, 0, { blazeView: newItemView });\n\n          var unusedDiv = document.createElement('div');\n          Blaze.render(newItemView, unusedDiv, eachView);\n\n          //Blaze.materializeView(newItemView, eachView);\n          //runRenderedCallback(newItemView);  // now called by Blaze.render\n        });\n      },\n      removedAt: function (id, item, index) {\n        // famousEachBlock, not individual Views\n        Blaze.remove(children[index].blazeView);\n        children.splice(index, 1);\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Tracker.nonreactive(function () {\n          children[index].blazeView.dataVar.set(newItem);\n        });\n      },\n      movedTo: function (id, doc, fromIndex, toIndex) {\n        Tracker.nonreactive(function () {\n          var item = sequence.splice(fromIndex, 1)[0];\n          sequence.splice(toIndex, 0, item);\n\n          item = children.splice(fromIndex, 1)[0];\n          children.splice(toIndex, 0, item);\n        });\n      }\n    });\n}\n\nfunction famousEachCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n\n  log.debug('New famousEach' + \" (#\" + fview.id + ')'\n    + ' (parent: ' + parentViewName(blazeView.parentView) + ','\n    + ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  fview.kind = 'famousEach';\n  fview.sequence = fview.parent.sequence.child();\n\n  // Contents of {{#famousEach}}block{{/famousEach}}\n  if (blazeView.templateContentBlock)\n    famousEachRender(blazeView, blazeView.templateContentBlock, function() {\n      return Blaze.getData(blazeView);\n    });\n}\n\nfunction famousEachDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousEachView = new Template(\n  'famousEach',       // viewName: \"famousEach\"\n  function() {        // Blaze.View \"renderFunc\"\n    var view = this;  // Blaze.View, viewName \"famousEach\"\n    // console.log(view);\n    return null;\n  }\n);\n\nBlaze.registerHelper('famousEach', FView.famousEachView);\nFView.famousEachView.created = famousEachCreated;\nFView.famousEachView.destroyed = famousEachDestroyed;\n\n/*\nFView.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('Feach', function() {\n    return null;\n  });\n\n  eachView.onCreated(function() {\n    // For Blaze.currentView (see blaze/builtins.js#each)\n    eachView.autorun(function () {\n      eachView.argVar.set(argFunc());\n    }, eachView.parentView);\n\n\n  });\n\n  return eachView;\n}\nBlaze.registerHelper('famousEach', FView.Each);\n*/","/*\n * In brief, on Create we setup a child sequence to serve as a placeholder for\n * any children (so that order is retained).  On reactive render, we destroy any\n * existing children and render the contentBlock / elseBlock (as our children).\n * On destroy, we cleanup and remove (TODO) child sequence placeholder.\n */\n\n/* Other thoughts:\n * - Currently this is only used to retain order in a sequence\n * - If used in a surface we could force rerun of autoHeight, etc?\n */\n\nfunction famousIfCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n\n  log.debug('New famousIf' + \" (#\" + fview.id + ')'\n    + ' (parent: ' + parentViewName(blazeView.parentView) + ','\n    + ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  fview.kind = 'famousIf';\n  fview.sequence = fview.parent.sequence.child();\n}\n\nfunction cleanupChildren(blazeView) {\n\tvar children = blazeView.fview.children;\n\tfor (var i=0; i < children.length; i++)\n  \tBlaze.remove(children[i].blazeView);\n}\n\nfunction famousIfDestroyed() {\n  this.view.fview.destroy(true);\n}\n\nFView.famousIfView = new Template('famousIf', function() {\n\tvar blazeView = this;\n\tvar condition = Blaze.getData(blazeView);\n\n  log.debug('famousIf' + \" (#\" + blazeView.fview.id + ')'\n    + ' is now ' + !!condition\n    + ' (parent: ' + parentViewName(blazeView.parentView) + ','\n    + ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  var dataContext = null /* this.data.data */\n    || Blaze._parentData(1) && Blaze._parentData(1, true)\n    || Blaze._parentData(0) && Blaze._parentData(0, true)\n    || {};\n\n  var unusedDiv = document.createElement('div');\n  var template = blazeView.templateContentBlock;\n\n  // Any time condition changes, remove all old children\n  cleanupChildren(blazeView);\n\n  var template = condition\n  \t? blazeView.templateContentBlock : blazeView.templateElseBlock;\n\n  if (template)\n\t  Blaze.renderWithData(template, dataContext, unusedDiv, null, blazeView);\n});\n\nBlaze.registerHelper('famousIf', FView.famousIfView);\nFView.famousIfView.created = famousIfCreated;\nFView.famousIfView.destroyed = famousIfDestroyed;\n","Template.famousContext\n\t= Template.FamousContext\n\t= new Template('Template.FamousContext', function() {\n\t  var blazeView = this;\n\n\t\tvar children = [];\n\t\tvar sequence = [];\n\n\t\t// Since all Surfaces are created in a .created callback, the expect to find a fview field on some parent.\n\t\t// Fake here one, and later link to real Context\n\t\tBlaze.getView().fview = {\n\t\t\tsequence : sequence,\n\t\t\tchildren : children\n\t\t};\n\n\t\tvar templateContentBlock = this.templateContentBlock;\n\n\t\tblazeView.onViewReady(function () {\n\t\t\tvar firstNode = $(this.templateInstance().firstNode);\n\t\t\tvar parent = firstNode.parent();\n\n\t\t\tvar context = famous.core.Engine.createContext(parent[0]);\n\n\t\t\t_.each(children, function (c) {\n\t\t\t\tcontext.add(c);\n\t\t\t});\n\t\t});\n\n\t\treturn Blaze.View('famousContext', function () {\n\t\t\treturn templateContentBlock;\n\t\t})\n\t});\n","FView.modifiers = {};\n\nfunction defaultCreate(options) {\n  return new this._modifier.modifier(options);\n}\n\nFView.registerModifier = function(name, modifier, options) {\n  if (!FView.modifiers[name])\n    FView.modifiers[name] = _.extend(\n      { create: defaultCreate },\n      options,\n      { name: name, modifier: modifier }\n    );\n}\n\nFView.ready(function(require) {\n\n  FView.registerModifier('modifier', famous.core.Modifier);\n\n  FView.registerModifier('identity', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.identity\n      }, options));\n    }\n  });\n\n  FView.registerModifier('inFront', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.inFront\n      }, options));\n    }\n  });\n\n  function modifierMethod(fview, method, value, options) {\n    if (typeof options.halt !== 'undefined'\n        ? options.halt : fview.modifierTransitionHalt)\n      fview.modifier.halt();\n\n    fview.modifier[method](\n      value,\n      options.transition || fview.modifierTransition,\n      options.done || fview.modifierTransitionDone\n    );\n  }\n  function degreesToRadians(x) {\n    return x * Math.PI / 180;\n  }\n  FView.registerModifier('StateModifier', famous.modifiers.StateModifier, {\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      // Allow for values like { value: 30, transition: {}, halt: true }\n      var options = {};\n      if (typeof value === 'object' && value && typeof value.value !== 'undefined') {\n        options = value;\n        value = options.value;\n      }\n      if (typeof oldValue === 'object' && oldValue && typeof oldValue.value !== 'undefined')\n        oldValue = oldValue.value;\n\n      switch(key) {\n        case 'transform': case 'opacity': case 'align': case 'size':\n          modifierMethod(this, 'set'+key[0].toUpperCase()+key.substr(1), value, options);\n          break;\n\n        // Below are helpful shortcuts for transforms\n\n        case 'translate':\n          modifierMethod(this, 'setTransform',\n            Transform.translate.apply(null, value), options);\n          break;\n\n        case 'scaleX': case 'scaleY': case 'scaleZ':\n          var amount = degreesToRadians((value || 0) - (oldValue || 0));\n          var scale = [0,0,0];\n          if (key == 'scaleX') scale[0] = amount;\n          else if (key == 'scaleY') scale[1] = amount;\n          else scale[2] = amount;\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.scale.apply(null, scale)\n          ), options);\n          break;\n\n        case 'skewX': case 'skewY':\n          var skewBy = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(skewBy))\n          ), options);\n          break;\n\n        case 'skewZ': // doesn't exist in famous\n          var skewBy = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.skew(0, 0, degreesToRadians(skewBy))\n          ), options);\n          break;\n\n        case 'rotateX': case 'rotateY': case 'rotateZ':\n          // value might be undefined from Session with no SessionDefault\n          var rotateBy = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(rotateBy))\n          ), options);\n          break;\n      }\n    }\n  });\n\n\n});\n\n/*\nFView.modifiers.pageTransition = function(blazeView, options) {\n  this.blazeView = blazeView;\n  this.famous = new Modifier({\n    transform : Transform.identity,\n    opacity   : 1,\n    origin    : [-0.5, -0.5],\n    size      : [100, 100]\n  });\n};\n\nFView.modifiers.pageTransition.prototype.postRender = function() {\n  this.famous.setOrigin([0,0], {duration : 5000});\n};\n*/","FView.views = {};\n\n/* Available in JS via `FView.views.Scrollview` and in templates via\n\t`{{#famous view='Scrollview'}}` or just `{{#Scrollview}}`. */\nFView.registerView = function(name, famousView, options) {\n\tif (FView.views[name])\n\t\treturn;\n\n  /*\n  var tpl = _.clone(FView.famousView);\n  tpl.viewName = 'Famous.' + name;\n  console.log(tpl);\n  */\n\n  var fview = FView.famousView;\n  var tpl = new Template('Famous.' + name, fview.renderFunction);\n  tpl.created = fview.created;\n  tpl.destroyed = fview.destroyed;\n  Blaze.registerHelper(name, tpl);\n\n\tFView.views[name]\n\t\t= _.extend(options || {}, { name: name, class: famousView });\n}\n\n/* Do we still need this?  Most people explicitly register views with\n   registerView() these days, to get the template helper */\nFView.getView = function(name)  {\n\t// @famono silent\n  if (FView.views[name])\n    return FView.views[name].class;\n  if (typeof Famous !== 'undefined' && Famous[name])\n    return Famous[name];\n  if (typeof Famous !== 'undefined' && famous.Views && Famous.Views[name])\n    return Famous.Views[name];\n  if (typeof famous !== 'undefined' && famous.views && famous.views[name])\n    return famous.views[name];\n  else\n    throw new Error('Wanted view \"' + name + '\" but it doesn\\'t exists.'\n      + ' Try FView.registerView(\"'+name+'\", require(...))');\n}\n","FView.ready(function(require) {\n\tFView.registerView('SequentialLayout', famous.views.SequentialLayout);\n\tFView.registerView('View', famous.core.View);\n});\n","FView.ready(function(require) {\n\tFView.registerView('ContainerSurface', famous.surfaces.ContainerSurface, {\n\n\t\tadd: function(child_fview, child_options) {\n\t\t\tthis.view.add(child_fview);\n    },\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n\t\t\tif (key == 'overflow')\n\t\t\t\tthis.view.setProperties({ overflow: value });\n\t\t\telse if (key == 'class')\n\t\t\t\tthis.view.setClasses(value.split(\" \"));\n\t\t}\n\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('EdgeSwapper', famous.views.EdgeSwapper, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tif (!this.view)\n\t\t\t\treturn;  // when?\n\n\t\t\tif (this.currentShow)\n\t\t\t\tthis.previousShow = this.currentShow;\n\t\t\tthis.currentShow = child_fview;\n\n\t\t\tchild_fview.preventDestroy();\n\n\t\t\tvar self = this;\n\t\t\tthis.view.show(child_fview, null, function() {\n\t\t\t\tif (self.previousShow)\n\t\t\t\t\tself.previousShow.destroy();\n\t\t\t});\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Flipper', famous.views.Flipper, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar target = child_options.target;\n\t\t\tif (!target || (target != 'back' && target != 'front'))\n\t\t\t\tthrow new Error('Flipper must specify target=\"back/front\"');\n\n\t\t\tif (target == 'front')\n\t\t\t\tthis.view.setFront(child_fview);\n\t\t\telse\n\t\t\t\tthis.view.setBack(child_fview);\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('HeaderFooterLayout', famous.views.HeaderFooterLayout, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar target = child_options.target;\n\t\t\tif (!target)\n\t\t\t\tthrow new Error('HeaderFooterLayout children must specify target=\"header/footer/content\"');\n\t\t\tthis.view[target].add(child_fview);\n\t\t}\n\t});\n});\n","FView.transitions = {\n\topacity: {\n    outTransformFrom: function(progress) {\n      return Transform.Identity;\n    },\n    inTransformFrom: function(progress) {\n      return Transform.Identity;\n    }\n\t},\n\tslideWindow: {\n    outTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * progress - window.innerWidth, 0, 0);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * (1.0 - progress), 0, 0);\n    }\n\t},\n\tWIP: {\n    outTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI*progress);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI + Math.PI*progress);\n    }\n\t}\n};\n\n// Other option is to allow a slideDirection attribute.  Think about this.\nFView.transitions.slideWindowLeft = FView.transitions.slideWindow;\nFView.transitions.slideWindowRight = {\n    outTransformFrom: FView.transitions.slideWindow.inTransformFrom,\n    inTransformFrom: FView.transitions.slideWindow.outTransformFrom\n};\n\nFView.ready(function(require) {\n\tFView.registerView('RenderController', famous.views.RenderController, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tif (!this.view)\n\t\t\t\treturn;  // when?\n\n\t\t\tif (this.currentShow)\n\t\t\t\tthis.previousShow = this.currentShow;\n\t\t\tthis.currentShow = child_fview;\n\n\t\t\tvar transition = child_options.transition;\n\t\t\tif (transition) {\n\t\t\t\tvar data = FView.transitions[transition];\n\t\t\t\tif (data) {\n\t\t\t\t\tfor (key in data)\n\t\t\t\t\t\tthis.view[key](data[key]);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error('No such transition ' + transition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild_fview.preventDestroy();\n\n\t\t\tvar self = this;\n\t\t\tthis.view.show(child_fview, null, function() {\n\t\t\t\tif (self.previousShow)\n\t\t\t\t\tself.previousShow.destroy();\n\t\t\t});\n\t\t},\n\n\t\tattrUpdate: function(key, value, oldValue, data, firstTime) {\n\t\t\tif (key == 'transition') {\n\t\t\t\tvar data = FView.transitions[value];\n\t\t\t\tif (data) {\n\t\t\t\t\tfor (key in data)\n\t\t\t\t\t\tthis.view[key](data[key]);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error('No such transition ' + transition);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Scrollview', famous.views.Scrollview, {\n\t\tfamousCreatedPost: function() {\n\t\t\tthis.pipeChildrenTo = this.parent.pipeChildrenTo\n\t\t\t\t? [ this.view, this.parent.pipeChildrenTo[0] ]\n\t\t\t\t: [ this.view ];\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Surface', famous.core.Surface, {\n\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar blazeView = this.blazeView;\n\n\t\t  log.error(\"You tried to embed a \" + child_fview._view.name + \" inside a Surface\"\n\t\t    + ' (parent: ' + parentViewName(blazeView) + ','\n\t\t    + ' template: ' + parentTemplateName(blazeView) + ').  '\n\t\t    + \"Surfaces are endpoints in the Famous Render Tree and may not contain \"\n\t\t  \t+ \"children themselves.  See \"\n\t\t    + \"https://github.com/gadicc/meteor-famous-views/issues/78 for more info.\");\n\n\t\t\tthrow new Error(\"Cannot add View to Surface\");\n\t\t},\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n    \tswitch(key) {\n    \t\tcase 'size':\n    \t\t\t// Let our modifier control our size\n    \t\t\t// Long term, rather specify modifierSize and surfaceSize args?\n    \t\t\tif (this._modifier.name == 'StateModifier')\n\t\t\t\t\t\tthis.surface.setSize([undefined,undefined]);\n    \t\t\telse {\n            this.surface.setSize(value);\n          }\n    \t\t\tbreak;\n\n        case 'class' :\n          if (Match.test(value, String))\n            value = value.split(\" \");\n          else if (!Match.test(value, [String]))\n            throw new Error('Surface class= expects string or array of strings');\n          value.push(this.surfaceClassName);\n          this.view.setClasses(value);\n          break;\n\n        case 'properties' :\n          this.view.setProperties(value);\n          break;\n    \t}\n    }\n\n\t});\n});\n"]}