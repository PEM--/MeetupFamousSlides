{"version":3,"file":"/packages/follower-livedata.js","sources":["follower-livedata/follower.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,0C;;;AAGA,iD;;AAEA,G;AACA,gF;AACA,+E;AACA,uD;AACA,E;AACA,a;AACA,+F;AACA,I;AACA,E;AACA,6E;AACA,yB;AACA,E;AACA,6E;AACA,wD;AACA,E;AACA,+E;AACA,qE;AACA,G;AACA,Y;AACA,uC;AACA,qB;AACA,wB;AACA,yC;AACA,gB;AACA,yD;;AAEA,8C;;AAEA,wB;AACA,uC;AACA,+E;AACA,O;AACA,qC;AACA,8B;AACA,S;AACA,M;;AAEA,6B;;AAEA,yB;AACA,yC;AACA,oB;AACA,6B;AACA,8B;AACA,yB;AACA,sB;AACA,2B;AACA,8B;;;AAGA,+E;AACA,8B;AACA,kD;;AAEA,qB;AACA,2B;AACA,4B;;AAEA,uC;AACA,sB;AACA,4B;AACA,sD;AACA,0B;AACA,sB;AACA,+B;AACA,S;AACA,S;AACA,6B;AACA,4D;AACA,oB;AACA,qD;AACA,O;AACA,wB;AACA,M;;AAEA,2C;AACA,0B;AACA,wB;AACA,iD;AACA,uF;AACA,S;AACA,M;;AAEA,qC;AACA,sB;AACA,kC;AACA,O;AACA,qC;AACA,oF;;AAEA,8E;AACA,kC;AACA,qC;AACA,O;;AAEA,iB;AACA,oC;AACA,kB;AACA,Y;AACA,c;AACA,yC;AACA,uC;AACA,yC;AACA,+B;AACA,O;AACA,sB;;AAEA,sC;AACA,wC;AACA,uE;AACA,2C;AACA,kC;AACA,oB;AACA,yB;AACA,mB;AACA,W;AACA,yD;AACA,0F;AACA,W;AACA,2B;AACA,0D;AACA,mD;AACA,W;AACA,0C;AACA,gC;;AAEA,2C;AACA,0B;AACA,uB;AACA,6B;AACA,2B;AACA,4D;AACA,a;AACA,kB;AACA,iE;AACA,8B;AACA,gD;AACA,qC;AACA,oB;AACA,4E;AACA,gD;AACA,a;;AAEA,W;AACA,gC;AACA,W;AACA,O;;AAEA,M;;AAEA,iB;;AAEA,uC;AACA,2E;AACA,qB;AACA,c;AACA,uE;AACA,oB;AACA,wC;AACA,yB;AACA,6C;AACA,uF;AACA,kC;AACA,mC;AACA,kB;AACA,4D;AACA,qD;AACA,a;AACA,2D;AACA,kC;AACA,W;AACA,W;AACA,O;AACA,M;;AAEA,yC;AACA,mE;AACA,M;;AAEA,yC;;AAEA,mC;AACA,yB;AACA,6C;AACA,4B;AACA,iC;AACA,M;;AAEA,kC;AACA,0B;AACA,6C;AACA,6C;AACA,2C;AACA,qB;AACA,c;AACA,6C;AACA,O;AACA,M;;AAEA,+B;AACA,4C;AACA,M;;AAEA,8B;AACA,0B;AACA,M;;;AAGA,+E;AACA,wE;AACA,wB;AACA,6C;AACA,sC;AACA,sD;AACA,6E;AACA,kC;AACA,4C;AACA,6C;AACA,W;AACA,4E;AACA,c;AACA,0C;AACA,2C;AACA,O;AACA,M;;AAEA,uC;AACA,mC;AACA,M;;AAEA,wC;AACA,oC;AACA,M;;AAEA,gB;AACA,G;;AAEA,E","sourcesContent":["var fs = Npm.require('fs');\nvar Future = Npm.require('fibers/future');\n\n\nvar MONITOR_INTERVAL = 5*1000; // every 5 seconds\n\n/**\n * Follower.connect() replaces DDP.connect() for connecting to DDP services that\n * implement a leadership set.  The follower connection tries to keep connected\n * to the leader, and fails over as the leader changes.\n *\n * Options: {\n * group: The name of the leadership group to connect to.  Default \"package.leadershipLivedata\"\n * }\n *\n * A Follower connection implements the following interfaces over and above a\n * normal DDP connection:\n *\n * onLost(callback): calls callback when the library considers itself to have\n * tried all its known options for the leadership group.\n *\n * onFound(callback): Called when the follower was previously lost, but has now\n * successfully connected to something in the right leadership group.\n */\nFollower = {\n  connect: function (urlSet, options) {\n    var electorTries;\n    options = _.extend({\n      group: \"package.leadershipLivedata\"\n    }, options);\n    // start each elector as untried/assumed connectable.\n\n    var makeElectorTries = function (urlSet) {\n\n      electorTries = {};\n      if (typeof urlSet === 'string') {\n        urlSet = _.map(urlSet.split(','), function (url) {return url.trim();});\n      }\n      _.each(urlSet, function (url) {\n        electorTries[url] = 0;\n      });\n    };\n\n    makeElectorTries(urlSet);\n\n    var tryingUrl = null;\n    var outstandingGetElectorate = false;\n    var conn = null;\n    var prevReconnect = null;\n    var prevDisconnect = null;\n    var prevApply = null;\n    var leader = null;\n    var connectedTo = null;\n    var intervalHandle = null;\n\n\n    // Used to defer all method calls until we're sure that we connected to the\n    // right leadership group.\n    var connectedToLeadershipGroup = new Future();\n\n    var lost = false;\n    var lostCallbacks = [];\n    var foundCallbacks = [];\n\n    var findFewestTries = function () {\n      var min = 10000;\n      var minElector = null;\n      _.each(electorTries, function (tries, elector) {\n        if (tries < min) {\n          min = tries;\n          minElector = elector;\n        }\n      });\n      if (min > 1 && !lost) {\n        // we've tried everything once; we just became lost.\n        lost = true;\n        _.each(lostCallbacks, function (f) { f(); });\n      }\n      return minElector;\n    };\n\n    var updateElectorate = function (res) {\n      leader = res.leader;\n      electorTries = {};\n      _.each(res.electorate, function (elector) {\n        electorTries[elector] = 0; // verified that this is in the current elector set.\n      });\n    };\n\n    var tryElector = function (url) {\n      if (tryingUrl) {\n        electorTries[tryingUrl]++;\n      }\n      url = url || findFewestTries();\n      //console.log(\"trying\", url, electorTries, tryingUrl, process.env.GALAXY_JOB);\n\n      // Don't keep trying the same url as fast as we can if it's not working.\n      if (electorTries[url] > 2) {\n        Meteor._sleepForMs(3 * 1000);\n      }\n\n      if (conn) {\n        prevReconnect.apply(conn, [{\n          url: url\n        }]);\n      } else {\n        conn = DDP.connect(url, options);\n        prevReconnect = conn.reconnect;\n        prevDisconnect = conn.disconnect;\n        prevApply = conn.apply;\n      }\n      tryingUrl = url;\n\n      if (!outstandingGetElectorate) {\n        outstandingGetElectorate = true;\n        conn.call('getElectorate', options.group, function (err, res) {\n          outstandingGetElectorate = false;\n          connectedTo = tryingUrl;\n          if (err) {\n            tryElector();\n            return;\n          }\n          if (!_.contains(res.electorate, connectedTo)) {\n            Log.warn(\"electorate \" + res.electorate + \" does not contain \" + connectedTo);\n          }\n          tryingUrl = null;\n          if (! connectedToLeadershipGroup.isResolved()) {\n            connectedToLeadershipGroup[\"return\"]();\n          }\n          // we got an answer!  Connected!\n          electorTries[url] = 0;\n\n          if (res.leader === connectedTo) {\n            // we're good.\n            if (lost) {\n              // we're found.\n              lost = false;\n              _.each(foundCallbacks, function (f) { f(); });\n            }\n          } else {\n            // let's connect to the leader anyway, if we think it\n            // is connectable.\n            if (electorTries[res.leader] == 0) {\n              tryElector(res.leader);\n            } else {\n              // XXX: leader is probably down, we're probably going to elect\n              // soon.  Wait for the next round.\n            }\n\n          }\n          updateElectorate(res);\n        });\n      }\n\n    };\n\n    tryElector();\n\n    var checkConnection = function () {\n      if (conn.status().status !== 'connected' || connectedTo !== leader) {\n        tryElector();\n      } else {\n        conn.call('getElectorate', options.group, function (err, res) {\n          if (err) {\n            electorTries[connectedTo]++;\n            tryElector();\n          } else if (res.leader !== leader) {\n            // update the electorate, and then definitely try to connect to the leader.\n            updateElectorate(res);\n            tryElector(res.leader);\n          } else {\n            if (! connectedToLeadershipGroup.isResolved()) {\n              connectedToLeadershipGroup[\"return\"]();\n            }\n            //console.log(\"updating electorate with\", res);\n            updateElectorate(res);\n          }\n        });\n      }\n    };\n\n    var monitorConnection = function () {\n      return Meteor.setInterval(checkConnection, MONITOR_INTERVAL);\n    };\n\n    intervalHandle = monitorConnection();\n\n    conn.disconnect = function () {\n      if (intervalHandle)\n        Meteor.clearInterval(intervalHandle);\n      intervalHandle = null;\n      prevDisconnect.apply(conn);\n    };\n\n    conn.reconnect = function () {\n      if (!intervalHandle)\n        intervalHandle = monitorConnection();\n      if (arguments[0] && arguments[0].url) {\n        makeElectorTries(arguments[0].url);\n        tryElector();\n      } else {\n        prevReconnect.apply(conn, arguments);\n      }\n    };\n\n    conn.getUrl = function () {\n      return _.keys(electorTries).join(',');\n    };\n\n    conn.tries = function () {\n      return electorTries;\n    };\n\n\n    // Assumes that `call` is implemented in terms of `apply`. All method calls\n    // should be deferred until we are sure we've connected to the right\n    // leadership group.\n    conn.apply = function (/* arguments */) {\n      var args = _.toArray(arguments);\n      if (typeof args[args.length-1] === 'function') {\n        // this needs to be independent of this fiber if there is a callback.\n        Meteor.defer(function () {\n          connectedToLeadershipGroup.wait();\n          return prevApply.apply(conn, args);\n        });\n        return null; // if there is a callback, the return value is not used\n      } else {\n        connectedToLeadershipGroup.wait();\n        return prevApply.apply(conn, args);\n      }\n    };\n\n    conn.onLost = function (callback) {\n      lostCallbacks.push(callback);\n    };\n\n    conn.onFound = function (callback) {\n      foundCallbacks.push(callback);\n    };\n\n    return conn;\n  }\n\n};\n"]}