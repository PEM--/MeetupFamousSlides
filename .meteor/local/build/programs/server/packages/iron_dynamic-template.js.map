{"version":3,"file":"/packages/iron:dynamic-template.js","sources":["iron:dynamic-template/version_conflict_error.js","iron:dynamic-template/dynamic_template.js","iron:dynamic-template/blaze_overrides.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+C;AACA,wB;AACA,uI;AACA,+F;AACA,sB;AACA,sE;AACA,S;AACA,wC;AACA,0C;AACA,oD;AACA,kD;AACA,O;AACA,0D;AACA,iC;AACA,yC;AACA,S;AACA,K;;AAEA,C;;;;;;;;;;;;;;;;;;;AClBA,+E;AACA,a;AACA,+E;AACA,sD;AACA,+B;AACA,yB;AACA,qC;;AAEA,+E;AACA,a;AACA,+E;AACA,+B;AACA,+C;AACA,E;;AAEA,+E;AACA,qB;AACA,+E;;AAEA,G;AACA,4E;AACA,iD;AACA,E;AACA,G;AACA,sC;AACA,0B;AACA,yC;AACA,oC;AACA,kD;AACA,kC;AACA,4B;AACA,6C;AACA,yC;;AAEA,+C;AACA,+B;;AAEA,mB;AACA,wB;AACA,4B;AACA,4B;AACA,mF;;AAEA,qC;AACA,yB;;AAEA,6D;AACA,2B;AACA,E;;AAEA,G;AACA,2B;AACA,G;AACA,uD;AACA,2D;AACA,2B;AACA,gC;AACA,W;AACA,G;;AAEA,2B;AACA,W;;AAEA,6B;;AAEA,2B;AACA,qB;AACA,sF;;AAEA,2D;AACA,4B;AACA,2G;AACA,E;;AAEA,G;AACA,mC;AACA,E;AACA,kD;AACA,G;AACA,8D;AACA,6B;AACA,kC;AACA,M;AACA,iC;AACA,E;;AAEA,G;AACA,wC;AACA,G;AACA,+C;AACA,kD;AACA,6B;AACA,yB;AACA,8B;AACA,E;;AAEA,G;AACA,+B;AACA,G;AACA,mD;AACA,uD;AACA,uB;AACA,4B;AACA,W;AACA,G;;AAEA,yB;AACA,sE;AACA,E;;AAEA,G;AACA,iD;AACA,G;AACA,uD;AACA,kB;;AAEA,uB;AACA,+D;AACA,G;;AAEA,wB;AACA,2B;;AAEA,sC;;AAEA,wD;AACA,wB;;AAEA,qE;AACA,uE;AACA,2B;AACA,qC;;AAEA,mC;AACA,yE;AACA,gF;AACA,0E;AACA,8E;AACA,wE;AACA,2E;AACA,+B;;AAEA,wC;AACA,oE;AACA,sB;AACA,U;AACA,+E;AACA,8D;AACA,oB;AACA,uC;AACA,O;AACA,K;;AAEA,kC;AACA,8B;AACA,uC;AACA,O;AACA,K;;AAEA,yC;AACA,kG;AACA,4B;AACA,oC;AACA,iC;AACA,O;AACA,K;;AAEA,oC;AACA,kD;AACA,2B;;AAEA,+B;AACA,a;;AAEA,yB;AACA,K;;AAEA,4D;AACA,uC;AACA,4E;AACA,c;AACA,sC;;AAEA,oC;;AAEA,8C;AACA,kD;AACA,gD;AACA,Y;AACA,uE;AACA,4B;AACA,2B;AACA,K;;AAEA,gB;AACA,I;;AAEA,mB;AACA,kC;AACA,wB;AACA,c;AACA,E;;AAEA,4D;AACA,kB;;AAEA,wE;AACA,0E;AACA,4E;AACA,+B;AACA,kB;;AAEA,6C;AACA,qC;AACA,8B;;AAEA,c;AACA,mE;AACA,6C;AACA,2C;;AAEA,gB;AACA,yB;AACA,0J;AACA,sB;AACA,iD;AACA,S;AACA,K;AACA,sD;AACA,+B;AACA,oB;AACA,oD;AACA,sC;AACA,2B;AACA,kB;AACA,2B;AACA,yB;AACA,G;;AAEA,c;AACA,E;;AAEA,G;AACA,uE;AACA,G;AACA,iD;AACA,uB;AACA,4B;AACA,qB;AACA,4B;AACA,2B;AACA,G;AACA,E;;AAEA,G;AACA,wB;AACA,G;AACA,gG;AACA,mD;AACA,4D;AACA,mB;AACA,gB;AACA,I;AACA,G;;AAEA,6D;AACA,sC;AACA,W;;AAEA,0C;AACA,oB;AACA,+E;AACA,kD;AACA,0B;AACA,G;AACA,E;;AAEA,uE;AACA,kB;;AAEA,uB;AACA,qC;;AAEA,qC;;AAEA,6B;AACA,8C;AACA,2B;AACA,kD;AACA,oC;AACA,wD;AACA,0E;AACA,O;AACA,2B;AACA,G;;AAEA,uB;AACA,E;;AAEA,uD;AACA,kB;AACA,mC;AACA,gC;AACA,uB;AACA,mC;;AAEA,Y;AACA,W;;AAEA,gC;;AAEA,gB;AACA,mC;;AAEA,0C;AACA,+C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,gD;AACA,uC;AACA,0B;AACA,2D;AACA,0B;AACA,yD;AACA,wC;AACA,uE;AACA,0C;AACA,6D;AACA,6D;AACA,e;AACA,Y;AACA,+B;AACA,iC;AACA,c;AACA,S;AACA,O;AACA,I;;AAEA,wB;AACA,6C;AACA,M;AACA,gC;AACA,E;;AAEA,uD;AACA,yD;AACA,0B;AACA,E;;AAEA,0E;AACA,6C;AACA,qC;AACA,sE;AACA,uC;AACA,sC;AACA,6B;AACA,e;;AAEA,oC;AACA,qC;AACA,8C;AACA,qC;AACA,wB;AACA,yD;AACA,wB;AACA,kD;AACA,sC;AACA,2D;AACA,2D;AACA,a;AACA,U;AACA,6B;AACA,+B;AACA,Y;AACA,O;AACA,K;AACA,E;;AAEA,G;AACA,uC;AACA,G;AACA,uD;AACA,0B;;AAEA,sB;AACA,W;AACA,yB;;AAEA,uC;AACA,kB;;AAEA,uB;AACA,iH;;AAEA,iB;AACA,yB;;AAEA,wE;;AAEA,c;AACA,E;;AAEA,G;AACA,0E;AACA,qB;AACA,G;AACA,wD;AACA,+B;AACA,E;;AAEA,G;AACA,6C;AACA,E;AACA,G;AACA,4D;AACA,kB;;AAEA,uC;AACA,iC;AACA,iC;AACA,iE;AACA,iE;AACA,gE;AACA,iE;AACA,kC;AACA,oC;AACA,O;AACA,G;;AAEA,c;AACA,E;;AAEA,+E;AACA,oC;AACA,+E;;AAEA,G;AACA,qE;AACA,8E;AACA,G;AACA,wD;AACA,iE;AACA,E;;AAEA,G;AACA,8D;AACA,G;AACA,kD;AACA,gB;AACA,uD;AACA,gC;AACA,Q;AACA,6B;AACA,G;;AAEA,c;AACA,E;;AAEA,G;AACA,gD;AACA,E;AACA,oE;AACA,wD;AACA,E;AACA,sE;AACA,6B;AACA,K;AACA,yC;AACA,G;AACA,yD;AACA,uC;;AAEA,c;AACA,gB;;AAEA,8B;AACA,gC;;AAEA,c;AACA,E;;AAEA,G;AACA,gF;AACA,8D;AACA,E;AACA,+E;AACA,+D;AACA,qE;AACA,E;AACA,W;AACA,E;AACA,yC;AACA,2C;AACA,sC;AACA,sB;AACA,G;AACA,wC;AACA,yB;AACA,2D;;AAEA,e;AACA,c;AACA,yB;AACA,U;AACA,oB;AACA,K;;AAEA,gB;AACA,I;AACA,E;;AAEA,G;AACA,gC;AACA,G;AACA,2C;AACA,wC;AACA,E;;AAEA,uD;AACA,W;AACA,a;AACA,kE;AACA,gB;AACA,mC;AACA,uC;AACA,2D;AACA,4B;AACA,Y;AACA,6B;AACA,K;AACA,G;;AAEA,mB;AACA,E;;AAEA,mE;AACA,W;AACA,W;AACA,kE;AACA,gB;AACA,mC;;AAEA,sC;AACA,2D;;AAEA,mC;AACA,oB;AACA,O;AACA,M;AACA,I;AACA,2B;AACA,G;;AAEA,mB;AACA,E;;AAEA,G;AACA,yE;AACA,kF;AACA,2E;AACA,wE;AACA,G;AACA,uE;AACA,W;AACA,a;AACA,kE;AACA,gB;AACA,mC;AACA,sC;AACA,2D;AACA,oE;AACA,oB;AACA,O;AACA,M;AACA,I;AACA,2B;AACA,G;;AAEA,mB;AACA,E;;AAEA,+E;AACA,gB;AACA,+E;AACA,sC;AACA,0F;AACA,0C;;AAEA,gC;AACA,iD;AACA,yD;AACA,wC;AACA,gB;AACA,M;AACA,C;;AAEA,+E;AACA,iB;AACA,+E;AACA,uC;;;;;;;;;;;;;;;;;;;AC9lBA,+E;AACA,a;AACA,+E;AACA,+B;AACA,yB;;AAEA,+E;AACA,qB;AACA,+E;AACA,G;AACA,yE;AACA,6E;AACA,8E;AACA,8E;AACA,yD;AACA,G;AACA,6C;AACA,2D;AACA,6E;;AAEA,a;AACA,uD;AACA,8D;AACA,0C;AACA,gF;AACA,K;AACA,U;AACA,6C;AACA,G;AACA,E","sourcesContent":["if (Package['cmather:iron-dynamic-template']) {\n  throw new Error(\"\\n\\n\\\n    Sorry! The cmather:iron-{x} packages were migrated to the new package system with the wrong name, and you have duplicate copies.\\n\\\n    You can see which cmather:iron-{x} packages have been installed by using this command:\\n\\n\\\n    > meteor list\\n\\n\\\n    Can you remove any installed cmather:iron-{x} packages like this:\\\n    \\n\\n\\\n    > meteor remove cmather:iron-core\\n\\\n    > meteor remove cmather:iron-router\\n\\\n    > meteor remove cmather:iron-dynamic-template\\n\\\n    > meteor remove cmather:iron-dynamic-layout\\n\\\n    \\n\\\n    The new packages are named iron:{x}. For example:\\n\\n\\\n    > meteor add iron:router\\n\\n\\\n    Sorry for the hassle, but thank you!\\\n    \\n\\n\\\n  \");\n\n}\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar debug = Iron.utils.debug('iron:dynamic-template');\nvar assert = Iron.utils.assert;\nvar get = Iron.utils.get;\nvar camelCase = Iron.utils.camelCase;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar typeOf = function (value) {\n  return Object.prototype.toString.call(value);\n};\n\n/*****************************************************************************/\n/* DynamicTemplate */\n/*****************************************************************************/\n\n/**\n * Render a component to the page whose template and data context can change\n * dynamically, either from code or from helpers.\n *\n */\nDynamicTemplate = function (options) {\n  this._id = Random.id(); \n  this.options = options = options || {};\n  this._template = options.template;\n  this._defaultTemplate = options.defaultTemplate;\n  this._content = options.content;\n  this._data = options.data;\n  this._templateDep = new Tracker.Dependency;\n  this._dataDep = new Tracker.Dependency;\n\n  this._lookupHostDep = new Tracker.Dependency;\n  this._lookupHostValue = null;\n\n  this._hooks = {};\n  this._eventMap = null;\n  this._eventHandles = null;\n  this._eventThisArg = null;\n  this.name = options.name || this.constructor.prototype.name || 'DynamicTemplate';\n\n  // has the Blaze.View been created?\n  this.isCreated = false;\n\n  // has the Blaze.View been destroyed and not created again?\n  this.isDestroyed = false;\n};\n\n/**\n * Get or set the template.\n */\nDynamicTemplate.prototype.template = function (value) {\n  if (arguments.length === 1 && value !== this._template) {\n    this._template = value;\n    this._templateDep.changed();\n    return;\n  }\n\n  if (arguments.length > 0)\n    return;\n\n  this._templateDep.depend();\n\n  // do we have a template?\n  if (this._template)\n    return (typeof this._template === 'function') ? this._template() : this._template;\n\n  // no template? ok let's see if we have a default one set\n  if (this._defaultTemplate)\n    return (typeof this._defaultTemplate === 'function') ? this._defaultTemplate() : this._defaultTemplate;\n};\n\n/**\n * Get or set the default template.\n *\n * This function does not change any dependencies.\n */\nDynamicTemplate.prototype.defaultTemplate = function (value) {\n  if (arguments.length === 1)\n    this._defaultTemplate = value;\n  else\n    return this._defaultTemplate;\n};\n\n/**\n * Clear the template and data contexts.\n */\nDynamicTemplate.prototype.clear = function () {\n  //XXX do we need to clear dependencies here too?\n  this._template = undefined;\n  this._data = undefined;\n  this._templateDep.changed();\n};\n\n/**\n * Get or set the data context.\n */\nDynamicTemplate.prototype.data = function (value) {\n  if (arguments.length === 1 && value !== this._data) {\n    this._data = value;\n    this._dataDep.changed();\n    return;\n  }\n\n  this._dataDep.depend();\n  return typeof this._data === 'function' ? this._data() : this._data;\n};\n\n/**\n * Create the view if it hasn't been created yet.\n */\nDynamicTemplate.prototype.create = function (options) {\n  var self = this;\n\n  if (this.isCreated) {\n    throw new Error(\"DynamicTemplate view is already created\");\n  }\n\n  this.isCreated = true;\n  this.isDestroyed = false;\n\n  var templateVar = ReactiveVar(null);\n\n  var view = Blaze.View('DynamicTemplate', function () {\n    var thisView = this;\n\n    // create the template dependency here because we need the entire\n    // dynamic template to re-render if the template changes, including\n    // the Blaze.With view.\n    var template = templateVar.get();\n\n    return Blaze.With(function () {\n      // NOTE: This will rerun anytime the data function invalidates this\n      // computation OR if created from an inclusion helper (see note below) any\n      // time any of the argument functions invlidate the computation. For\n      // example, when the template changes this function will rerun also. But\n      // it's probably generally ok. The more serious use case is to not\n      // re-render the entire template every time the data context changes.\n      var result = self.data();\n\n      if (typeof result !== 'undefined')\n        // looks like data was set directly on this dynamic template\n        return result;\n      else\n        // return the first parent data context that is not inclusion arguments\n        return DynamicTemplate.getParentDataContext(thisView);\n    }, function () {\n      return self.renderView(template);\n    });\n  });\n\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      templateVar.set(self.template());\n    });\n  });\n\n  // wire up the view lifecycle callbacks\n  _.each(['onViewCreated', 'onViewReady', '_onViewRendered', 'onViewDestroyed'], function (hook) {\n    view[hook](function () {\n      // \"this\" is the view instance\n      self._runHooks(hook, this);\n    });\n  });\n\n  view._onViewRendered(function () {\n    // avoid inserting the view twice by accident.\n    self.isInserted = true;\n\n    if (view.renderCount !== 1)\n      return;\n\n    self._attachEvents();\n  });\n\n  view._templateInstance = new Blaze.TemplateInstance(view);\n  view.templateInstance = function () {\n    // Update data, firstNode, and lastNode, and return the TemplateInstance\n    // object.\n    var inst = view._templateInstance;\n\n    inst.data = Blaze.getData(view);\n\n    if (view._domrange && !view.isDestroyed) {\n      inst.firstNode = view._domrange.firstNode();\n      inst.lastNode = view._domrange.lastNode();\n    } else {\n      // on 'created' or 'destroyed' callbacks we don't have a DomRange\n      inst.firstNode = null;\n      inst.lastNode = null;\n    }\n\n    return inst;\n  };\n\n  this.view = view;\n  view.__dynamicTemplate__ = this;\n  view.name = this.name;\n  return view;\n};\n\nDynamicTemplate.prototype.renderView = function (template) {\n  var self = this;\n\n  // NOTE: When DynamicTemplate is used from a template inclusion helper\n  // like this {{> DynamicTemplate template=getTemplate data=getData}} the\n  // function below will rerun any time the getData function invalidates the\n  // argument data computation.\n  var tmpl = null;\n\n  // is it a template name like \"MyTemplate\"?\n  if (typeof template === 'string') {\n    tmpl = Template[template];\n\n    if (!tmpl)\n      // as a fallback double check the user didn't actually define\n      // a camelCase version of the template.\n      tmpl = Template[camelCase(template)];\n\n    if (!tmpl) {\n      tmpl = Blaze.With({\n        msg: \"Couldn't find a template named \" + JSON.stringify(template) + \" or \" + JSON.stringify(camelCase(template))+ \". Are you sure you defined it?\"\n      }, function () {\n        return Template.__DynamicTemplateError__;\n      });\n    }\n  } else if (typeOf(template) === '[object Object]') {\n    // or maybe a view already?\n    tmpl = template;\n  } else if (typeof self._content !== 'undefined') {\n    // or maybe its block content like\n    // {{#DynamicTemplate}}\n    //  Some block\n    // {{/DynamicTemplate}}\n    tmpl = self._content;\n  }\n\n  return tmpl;\n};\n\n/**\n * Destroy the dynamic template, also destroying the view if it exists.\n */\nDynamicTemplate.prototype.destroy = function () {\n  if (this.isCreated) {\n    Blaze.remove(this.view);\n    this.view = null;\n    this.isDestroyed = true;\n    this.isCreated = false;\n  }\n};\n\n/**\n * View lifecycle hooks.\n */\n_.each(['onViewCreated', 'onViewReady', '_onViewRendered', 'onViewDestroyed'], function (hook) {\n  DynamicTemplate.prototype[hook] = function (cb) {\n    var hooks = this._hooks[hook] = this._hooks[hook] || [];\n    hooks.push(cb);\n    return this;\n  };\n});\n\nDynamicTemplate.prototype._runHooks = function (name, view) {\n  var hooks = this._hooks[name] || [];\n  var hook;\n\n  for (var i = 0; i < hooks.length; i++) {\n    hook = hooks[i];\n    // keep the \"thisArg\" pointing to the view, but make the first parameter to\n    // the callback teh dynamic template instance.\n    hook.call(view, this);\n  }\n};\n\nDynamicTemplate.prototype.events = function (eventMap, thisInHandler) {\n  var self = this;\n\n  this._detachEvents();\n  this._eventThisArg = thisInHandler;\n\n  var boundMap = this._eventMap = {};\n\n  for (var key in eventMap) {\n    boundMap[key] = (function (key, handler) {\n      return function (e) {\n        var data = Blaze.getData(e.currentTarget);\n        if (data == null) data = {};\n        var tmplInstance = self.view.templateInstance();\n        return handler.call(thisInHandler || this, e, tmplInstance, data);\n      }\n    })(key, eventMap[key]);\n  }\n\n  this._attachEvents();\n};\n\nDynamicTemplate.prototype._attachEvents = function () {\n  var self = this;\n  var thisArg = self._eventThisArg;\n  var boundMap = self._eventMap;\n  var view = self.view;\n  var handles = self._eventHandles;\n\n  if (!view)\n    return;\n\n  var domrange = view._domrange;\n\n  if (!domrange)\n    throw new Error(\"no domrange\");\n\n  var attach = function (range, element) {\n    _.each(boundMap, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        handles.push(Blaze._EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget))\n              return null;\n            var handlerThis = self._eventThisArg || this;\n            var handlerArgs = arguments;\n            //XXX which view should this be? What if the event happened\n            //somwhere down the hierarchy?\n            return Blaze._withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  };\n\n  if (domrange.attached)\n    attach(domrange, domrange.parentElement);\n  else\n    domrange.onAttached(attach);\n};\n\nDynamicTemplate.prototype._detachEvents = function () {\n  _.each(this._eventHandles, function (h) { h.stop(); });\n  this._eventHandles = [];\n};\n\nvar attachEventMaps = function (range, element, eventMap, thisInHandler) {\n  _.each(eventMap, function (handler, spec) {\n    var clauses = spec.split(/,\\s+/);\n    // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n    _.each(clauses, function (clause) {\n      var parts = clause.split(/\\s+/);\n      if (parts.length === 0)\n        return;\n\n      var newEvents = parts.shift();\n      var selector = parts.join(' ');\n      handles.push(Blaze._EventSupport.listen(\n        element, newEvents, selector,\n        function (evt) {\n          if (! range.containsElement(evt.currentTarget))\n            return null;\n          var handlerThis = thisInHandler || this;\n          var handlerArgs = arguments;\n          return Blaze._withCurrentView(view, function () {\n            return handler.apply(handlerThis, handlerArgs);\n          });\n        },\n        range, function (r) {\n          return r.parentRange;\n        }));\n    });\n  });\n};\n\n/**\n * Insert the Layout view into the dom.\n */\nDynamicTemplate.prototype.insert = function (options) {\n  options = options || {};\n\n  if (this.isInserted)\n    return;\n  this.isInserted = true;\n\n  var el = options.el || document.body;\n  var $el = $(el);\n\n  if ($el.length === 0)\n    throw new Error(\"No element to insert layout into. Is your element defined? Try a Meteor.startup callback.\");\n\n  if (!this.view)\n    this.create(options);\n\n  Blaze.render(this.view, $el[0], options.nextNode, options.parentView);\n\n  return this;\n};\n\n/**\n * Reactively return the value of the current lookup host or null if there\n * is no lookup host.\n */\nDynamicTemplate.prototype._getLookupHost = function () {\n  return this._lookupHostValue;\n};\n\n/**\n * Set the reactive value of the lookup host.\n *\n */\nDynamicTemplate.prototype._setLookupHost = function (host) {\n  var self = this;\n\n  if (self._lookupHostValue !== host) {\n    self._lookupHostValue = host;\n    Deps.afterFlush(function () {\n      // if the lookup host changes and the template also changes\n      // before the next flush cycle, this gives the new template\n      // a chance to render, and the old template to be torn off\n      // the page (including stopping its computation) before the\n      // lookupHostDep is changed.\n      self._lookupHostDep.changed();\n    });\n  }\n\n  return this;\n};\n\n/*****************************************************************************/\n/* DynamicTemplate Static Methods */\n/*****************************************************************************/\n\n/**\n * Get the first parent data context that are not inclusion arguments\n * (see above function). Note: This function can create reactive dependencies.\n */\nDynamicTemplate.getParentDataContext = function (view) {\n  return DynamicTemplate.getDataContext(view && view.parentView);\n};\n\n/**\n * Get the first data context that is not inclusion arguments.\n */\nDynamicTemplate.getDataContext = function (view) {\n  while (view) {\n    if (view.name === 'with' && !view.__isTemplateWith)\n      return view.dataVar.get();\n    else\n      view = view.parentView;\n  }\n\n  return null;\n};\n\n/**\n * Get inclusion arguments, if any, from a view.\n *\n * Uses the __isTemplateWith property set when a parent view is used\n * specificially for a data context with inclusion args.\n *\n * Inclusion arguments are arguments provided in a template like this:\n * {{> yield \"inclusionArg\"}}\n * or\n * {{> yield region=\"inclusionArgValue\"}}\n */\nDynamicTemplate.getInclusionArguments = function (view) {\n  var parent = view && view.parentView;\n\n  if (!parent)\n    return null;\n\n  if (parent.__isTemplateWith)\n    return parent.dataVar.get();\n\n  return null;\n};\n\n/**\n * Given a view, return a function that can be used to access argument values at\n * the time the view was rendered. There are two key benefits:\n *\n * 1. Save the argument data at the time of rendering. When you use lookup(...)\n *    it starts from the current data context which can change.\n * 2. Defer creating a dependency on inclusion arguments until later.\n *\n * Example:\n *\n *   {{> MyTemplate template=\"MyTemplate\"\n *   var args = DynamicTemplate.args(view);\n *   var tmplValue = args('template');\n *     => \"MyTemplate\"\n */\nDynamicTemplate.args = function (view) {\n  return function (key) {\n    var data = DynamicTemplate.getInclusionArguments(view);\n\n    if (data) {\n      if (key)\n        return data[key];\n      else\n        return data;\n    }\n\n    return null;\n  };\n};\n\n/**\n * Inherit from DynamicTemplate.\n */\nDynamicTemplate.extend = function (props) {\n  return Iron.utils.extend(this, props);\n};\n\nDynamicTemplate.findFirstLookupHost = function (view) {\n  var host;\n  var helper;\n  assert(view instanceof Blaze.View, \"view must be a Blaze.View\");\n  while (view) {\n    if (view.__dynamicTemplate__) {\n      // creates a reactive dependency.\n      var host = view.__dynamicTemplate__._getLookupHost();\n      if (host) return host;\n    } else {\n      view = view.parentView;\n    }\n  }\n\n  return undefined;\n};\n\nDynamicTemplate.findLookupHostWithProperty = function (view, key) {\n  var host;\n  var prop;\n  assert(view instanceof Blaze.View, \"view must be a Blaze.View\");\n  while (view) {\n    if (view.__dynamicTemplate__) {\n\n      // creates a reactive dependency\n      var host = view.__dynamicTemplate__._getLookupHost();\n\n      if (host && get(host, key)) {\n        return host;\n      }\n    } \n    \n    view = view.parentView;\n  }\n\n  return undefined;\n};\n\n/**\n * Find a lookup host that has a given helper and returns the host. Note,\n * this will create a reactive dependency on each dynamic template's getLookupHost\n * function. This is required becuase we need to rerun the entire lookup if\n * the host changes or is added or removed later, anywhere in the chain.\n */\nDynamicTemplate.findLookupHostWithHelper = function (view, helperKey) {\n  var host;\n  var helper;\n  assert(view instanceof Blaze.View, \"view must be a Blaze.View\");\n  while (view) {\n    if (view.__dynamicTemplate__) {\n      // creates a reactive dependency\n      var host = view.__dynamicTemplate__._getLookupHost();\n      if (host && get(host, 'constructor', '_helpers', helperKey)) {\n        return host;\n      }\n    } \n    \n    view = view.parentView;\n  }\n\n  return undefined;\n};\n\n/*****************************************************************************/\n/* UI Helpers */\n/*****************************************************************************/\nif (typeof Template !== 'undefined') {\n  UI.registerHelper('DynamicTemplate', new Template('DynamicTemplateHelper', function () {\n    var args = DynamicTemplate.args(this);\n\n    return new DynamicTemplate({\n      data: function () { return args('data'); },\n      template: function () { return args('template'); },\n      content: this.templateContentBlock\n    }).create();\n  }));\n}\n\n/*****************************************************************************/\n/* Namespacing */\n/*****************************************************************************/\nIron.DynamicTemplate = DynamicTemplate;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar assert = Iron.utils.assert;\nvar get = Iron.utils.get;\n\n/*****************************************************************************/\n/* Blaze Overrides */\n/*****************************************************************************/\n/**\n * Adds ability to inject lookup hosts into views that can participate in\n * property lookup. For example, iron:controller or iron:component could make\n * use of this to add methods into the lookup chain. If the property is found,\n * a function is returned that either returns the property value or the result\n * of calling the function (bound to the __lookupHost__).\n */\nvar origLookup = Blaze.View.prototype.lookup;\nBlaze.View.prototype.lookup = function (name /*, args */) {\n  var host = DynamicTemplate.findLookupHostWithHelper(Blaze.getView(), name);\n\n  if (host) {\n    return function callLookupHostHelper (/* args */) {\n      var helper = get(host, 'constructor', '_helpers', name);\n      var args = [].slice.call(arguments);\n      return (typeof helper === 'function') ? helper.apply(host, args) : helper;\n    }\n  } else {\n    return origLookup.apply(this, arguments);\n  }\n};\n"]}