{"version":3,"file":"/packages/iron:router.js","sources":["iron:router/lib/current_options.js","iron:router/lib/http_methods.js","iron:router/lib/route_controller.js","iron:router/lib/route_controller_server.js","iron:router/lib/route.js","iron:router/lib/router.js","iron:router/lib/hooks.js","iron:router/lib/helpers.js","iron:router/lib/body_parser_server.js","iron:router/lib/router_server.js","iron:router/lib/plugins.js","iron:router/lib/global_router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,4E;AACA,6D;AACA,G;AACA,gD;;;;;;;;;;;;;;;;;;;ACJA,gB;AACA,Q;AACA,S;AACA,Q;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;ACLA,+E;AACA,a;AACA,+E;AACA,iC;AACA,mB;AACA,2C;AACA,+B;;AAEA,+E;AACA,qB;AACA,+E;AACA,qC;AACA,mC;AACA,iE;AACA,4B;AACA,2B;AACA,+B;AACA,+B;AACA,qB;;AAEA,mE;AACA,sE;AACA,qE;AACA,oE;AACA,wE;AACA,yC;;AAEA,mC;AACA,qC;AACA,yC;AACA,+C;;AAEA,uB;AACA,G;AACA,G;;AAEA,G;AACA,2E;AACA,E;AACA,iB;AACA,0C;AACA,uB;AACA,qB;AACA,wB;AACA,G;AACA,yD;AACA,uB;AACA,gF;AACA,+E;AACA,+E;AACA,2E;AACA,4E;AACA,kD;AACA,yE;AACA,mC;;AAEA,iB;AACA,+B;AACA,6B;;AAEA,qC;AACA,uC;AACA,qB;;AAEA,4D;AACA,kC;AACA,+B;AACA,qB;;AAEA,wB;AACA,4E;AACA,oC;AACA,E;;AAEA,+E;AACA,0D;AACA,0B;AACA,uC;AACA,yC;AACA,gC;AACA,gD;AACA,oC;AACA,mB;AACA,sD;AACA,oD;AACA,G;AACA,E;;AAEA,G;AACA,yE;AACA,2B;AACA,E;AACA,sB;AACA,qB;AACA,8B;AACA,iC;AACA,E;AACA,6D;AACA,gF;AACA,a;AACA,E;AACA,0E;AACA,4B;AACA,E;AACA,6E;AACA,yD;AACA,G;AACA,+E;AACA,kB;AACA,uC;;AAEA,wC;AACA,e;AACA,gB;AACA,4C;AACA,mD;AACA,gE;AACA,I;;AAEA,yD;AACA,mB;;AAEA,uB;AACA,wF;;AAEA,4C;AACA,oE;AACA,I;;AAEA,gC;AACA,gD;AACA,uB;AACA,K;AACA,I;;AAEA,uB;AACA,4B;AACA,kD;AACA,iD;AACA,4C;AACA,K;;AAEA,sB;AACA,4B;AACA,8D;AACA,0C;AACA,K;;AAEA,qB;AACA,4B;AACA,4B;AACA,4C;AACA,0C;AACA,K;AACA,K;;AAEA,sB;AACA,mB;AACA,8B;AACA,0D;AACA,4C;AACA,O;AACA,G;;AAEA,4B;AACA,uB;AACA,uB;AACA,uB;;AAEA,kB;AACA,E;;AAEA,G;AACA,gE;AACA,G;AACA,yE;AACA,wD;AACA,iD;AACA,qB;AACA,iB;AACA,G;AACA,sB;AACA,E;;AAEA,mD;AACA,qB;AACA,E;;AAEA,wD;AACA,sB;AACA,c;AACA,E;;AAEA,uC;;;;;;;;;;;;;;;;;;;ACjMA,+E;AACA,a;AACA,+E;AACA,kC;AACA,iC;AACA,mB;AACA,2C;;AAEA,+E;AACA,qB;AACA,+E;;AAEA,G;AACA,kC;AACA,G;AACA,uD;;AAEA,G;AACA,2E;AACA,8E;AACA,8E;AACA,0E;AACA,gB;AACA,G;AACA,kE;AACA,kB;AACA,qB;AACA,oC;AACA,W;AACA,E;;AAEA,G;AACA,2E;AACA,2E;AACA,uE;AACA,a;AACA,E;AACA,e;AACA,E;AACA,mE;AACA,E;AACA,2E;AACA,6E;AACA,uD;AACA,G;AACA,mE;AACA,kB;AACA,kC;;AAEA,uD;AACA,sD;;AAEA,mE;AACA,+C;;AAEA,4E;AACA,2B;AACA,wC;AACA,kE;AACA,G;;AAEA,2C;AACA,kC;;AAEA,yB;AACA,6B;AACA,0C;AACA,E;;;;;;;;;;;;;;;;;;;ACnEA,mB;AACA,2C;AACA,+B;;AAEA,+E;AACA,U;AACA,+E;AACA,sC;AACA,yC;AACA,0B;AACA,6B;AACA,8B;AACA,8C;AACA,G;;AAEA,+B;AACA,iB;AACA,wB;AACA,G;;AAEA,0B;;AAEA,2D;AACA,mD;AACA,G;;AAEA,yE;AACA,e;AACA,wB;;AAEA,gC;AACA,0C;;AAEA,+E;AACA,qB;AACA,2C;;AAEA,4E;AACA,6B;AACA,2C;AACA,0D;AACA,kD;;AAEA,+C;AACA,0C;AACA,wD;AACA,gD;;;AAGA,wC;AACA,sB;;AAEA,+B;AACA,qD;AACA,kB;AACA,Q;AACA,kE;AACA,+C;AACA,G;;AAEA,qB;AACA,e;AACA,E;;AAEA,G;AACA,6E;AACA,qD;AACA,G;AACA,uC;AACA,2C;AACA,E;;AAEA,G;AACA,qE;AACA,E;AACA,iC;AACA,E;AACA,0D;AACA,gF;AACA,gC;AACA,E;AACA,G;AACA,yD;AACA,kB;;AAEA,uC;AACA,sB;AACA,qC;AACA,sE;AACA,sC;AACA,0E;AACA,U;AACA,yB;AACA,Y;AACA,e;AACA,K;AACA,I;;AAEA,iC;AACA,8C;AACA,I;;AAEA,a;AACA,4B;;AAEA,oC;AACA,oD;AACA,mC;;AAEA,8E;AACA,iC;AACA,uD;AACA,4C;;AAEA,8E;AACA,8B;AACA,4E;AACA,kB;;AAEA,qD;AACA,M;AACA,2B;AACA,E;;;AAGA,G;AACA,yC;AACA,G;AACA,uD;AACA,0B;AACA,2C;AACA,uB;AACA,gC;AACA,kB;AACA,E;;AAEA,kE;AACA,E;;AAEA,G;AACA,8C;AACA,G;AACA,0D;AACA,gF;AACA,mB;AACA,uE;AACA,4C;AACA,E;;AAEA,G;AACA,yC;AACA,G;AACA,mD;AACA,+C;AACA,E;;AAEA,G;AACA,2E;AACA,+B;AACA,G;AACA,kD;AACA,wC;AACA,+D;;AAEA,0C;AACA,wC;AACA,qB;AACA,E;;AAEA,G;AACA,qD;AACA,G;AACA,0C;AACA,mC;AACA,E;;AAEA,G;AACA,8C;AACA,E;AACA,W;AACA,qC;AACA,2B;AACA,4B;AACA,2B;AACA,G;AACA,wC;AACA,2C;AACA,wD;AACA,iC;;AAEA,4C;AACA,4E;AACA,iC;AACA,wD;AACA,qB;;AAEA,gF;AACA,sB;AACA,gC;AACA,kB;AACA,O;;AAEA,gB;AACA,I;AACA,G;;AAEA,mB;;;;;;;;;;;;;;;;;;;AC9MA,+E;AACA,a;AACA,+E;AACA,2C;AACA,mB;AACA,yB;AACA,2B;AACA,+B;;AAEA,6B;AACA,2C;AACA,4B;AACA,oC;AACA,wF;AACA,8B;AACA,mB;AACA,mB;AACA,a;AACA,G;;AAEA,0B;AACA,sC;;AAEA,sD;AACA,2B;;AAEA,8E;AACA,c;AACA,qB;;AAEA,4D;AACA,6B;;AAEA,gC;AACA,uC;;AAEA,gD;AACA,yB;;AAEA,mE;AACA,kC;;AAEA,8B;AACA,8B;AACA,6C;AACA,uB;AACA,O;AACA,K;;AAEA,gB;AACA,E;;AAEA,8C;;AAEA,iD;AACA,kB;;AAEA,0B;;AAEA,kC;AACA,e;AACA,gB;;AAEA,yB;AACA,mB;;AAEA,mB;AACA,I;;AAEA,0C;AACA,+D;AACA,wB;AACA,+D;AACA,iC;AACA,S;;AAEA,2B;AACA,K;AACA,K;;AAEA,oC;AACA,kC;;AAEA,c;AACA,E;;AAEA,G;AACA,qE;AACA,G;AACA,sC;AACA,uB;AACA,E;;AAEA,E;AACA,mE;AACA,kD;AACA,mC;AACA,oB;AACA,sB;AACA,wC;AACA,iC;AACA,U;AACA,sB;AACA,sB;AACA,wC;AACA,qC;AACA,G;;AAEA,c;AACA,E;AACA,E;;AAEA,wF;AACA,oD;AACA,8E;AACA,2J;;AAEA,+B;AACA,c;AACA,qB;AACA,G;;AAEA,wC;;AAEA,oB;;AAEA,0B;AACA,qB;;AAEA,wE;AACA,oD;;AAEA,wB;AACA,0B;AACA,sB;AACA,E;AACA,4C;AACA,qI;AACA,4C;;AAEA,0B;;AAEA,uC;AACA,sC;;AAEA,e;AACA,E;;AAEA,G;AACA,sD;AACA,G;AACA,kD;AACA,gD;AACA,6C;AACA,4B;AACA,G;;AAEA,c;AACA,E;;AAEA,+D;AACA,qC;AACA,+J;AACA,8C;AACA,E;;AAEA,8D;AACA,qC;AACA,8J;AACA,6C;AACA,E;;AAEA,G;AACA,0C;AACA,G;AACA,6D;AACA,wC;AACA,uC;AACA,iB;;AAEA,0B;;AAEA,Y;AACA,kD;AACA,gE;AACA,M;AACA,qC;AACA,6D;;AAEA,2B;AACA,+D;AACA,oB;AACA,E;;AAEA,2D;AACA,mC;AACA,c;AACA,E;;AAEA,6D;AACA,qC;AACA,c;AACA,E;;AAEA,kD;AACA,kC;AACA,4C;AACA,M;AACA,qC;AACA,E;;AAEA,oD;AACA,oC;AACA,8C;AACA,M;AACA,oD;AACA,E;;AAEA,G;AACA,E;AACA,gE;AACA,+E;AACA,E;AACA,sE;AACA,qE;AACA,2C;AACA,uB;AACA,c;AACA,E;AACA,G;;AAEA,0D;AACA,kB;;AAEA,0B;;AAEA,kC;AACA,e;AACA,gB;AACA,8B;AACA,mB;AACA,Q;AACA,qB;AACA,G;;AAEA,mB;AACA,yC;AACA,qB;AACA,6C;;AAEA,sE;;AAEA,qC;AACA,uB;AACA,yB;AACA,+E;AACA,0E;AACA,wE;AACA,0E;AACA,yE;AACA,gF;AACA,2E;AACA,0D;AACA,wD;AACA,O;AACA,I;;AAEA,wD;AACA,c;AACA,E;;AAEA,G;AACA,6E;AACA,+E;AACA,uB;AACA,G;AACA,mD;AACA,oB;;AAEA,6C;AACA,uB;AACA,c;;AAEA,6C;AACA,mD;AACA,W;AACA,uB;AACA,4C;AACA,mC;AACA,G;;AAEA,0C;AACA,sD;AACA,E;;AAEA,G;AACA,E;AACA,qE;AACA,sD;AACA,E;AACA,sD;AACA,oE;AACA,wD;AACA,c;AACA,E;AACA,G;;AAEA,kD;AACA,kB;AACA,iB;;AAEA,kD;AACA,+B;;AAEA,0D;AACA,gB;;AAEA,wD;AACA,gB;;AAEA,0B;AACA,K;;AAEA,e;AACA,E;;AAEA,qB;AACA,U;AACA,Y;AACA,mB;AACA,kB;AACA,W;;AAEA,4C;AACA,6C;AACA,mD;AACA,qD;AACA,W;;AAEA,+C;AACA,kB;AACA,6B;AACA,2B;AACA,oB;AACA,E;;AAEA,G;AACA,uC;AACA,G;AACA,kB;;;AAGA,G;AACA,kD;AACA,G;AACA,oB;;AAEA,G;AACA,6C;AACA,G;;AAEA,2C;AACA,qD;AACA,sC;AACA,I;AACA,G;;AAEA,G;AACA,uC;AACA,G;AACA,wD;AACA,W;;AAEA,qC;AACA,oB;AACA,wC;AACA,yC;;AAEA,Y;AACA,yE;;AAEA,wB;AACA,iC;;AAEA,c;AACA,E;;AAEA,qB;;;;;;;;;;;;;;;;;;;ACnYA,sC;AACA,K;AACA,4C;AACA,K;AACA,mF;AACA,wB;AACA,K;;AAEA,K;AACA,mD;AACA,K;AACA,6F;AACA,+B;AACA,K;AACA,C;;AAEA,G;AACA,sE;AACA,8E;AACA,oC;AACA,G;;AAEA,oC;AACA,qC;AACA,qB;AACA,gB;AACA,W;AACA,G;;AAEA,sD;AACA,kD;AACA,uB;AACA,E;;AAEA,G;AACA,gF;AACA,Q;AACA,G;AACA,yC;AACA,sB;AACA,gB;AACA,W;AACA,G;;AAEA,uC;AACA,gB;AACA,uD;;AAEA,mC;AACA,yC;AACA,2D;AACA,2B;AACA,a;AACA,K;AACA,G;;AAEA,wC;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC1DA,+E;AACA,a;AACA,+E;AACA,2B;AACA,2C;AACA,sD;;AAEA,+E;AACA,gB;AACA,+E;;AAEA,G;AACA,sE;AACA,kB;AACA,G;AACA,sE;AACA,6B;AACA,I;;AAEA,G;AACA,8E;AACA,uB;AACA,G;AACA,iD;AACA,gB;;AAEA,6B;AACA,6B;AACA,iC;AACA,I;;AAEA,qC;;AAEA,oB;;AAEA,gB;AACA,yB;AACA,uB;AACA,0C;AACA,6C;;AAEA,uC;AACA,kF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,wD;AACA,G;;AAEA,c;AACA,G;;AAEA,G;AACA,8E;AACA,uB;AACA,G;AACA,gD;AACA,gB;;AAEA,6B;AACA,6B;AACA,iC;AACA,I;;AAEA,qC;;AAEA,oB;AACA,e;AACA,yB;AACA,uB;AACA,0C;AACA,6C;;AAEA,uC;AACA,iF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,sD;AACA,G;;AAEA,a;AACA,G;;AAEA,G;AACA,6C;AACA,E;AACA,W;AACA,qE;AACA,uC;AACA,gB;AACA,G;AACA,sE;AACA,kB;AACA,yD;;AAEA,+B;AACA,6I;;AAEA,oB;AACA,gB;AACA,yB;AACA,uB;AACA,6B;AACA,mF;AACA,uC;AACA,gB;;AAEA,iF;;AAEA,c;AACA,iE;AACA,+B;AACA,6B;AACA,2C;;AAEA,sE;AACA,yB;AACA,O;AACA,O;;AAEA,wD;AACA,G;;AAEA,0E;AACA,6B;AACA,6D;AACA,oB;;AAEA,iC;AACA,sD;AACA,kB;AACA,oD;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACxJA,+C;;;;;;;;;;;;;;;;;;;ACAA,+B;;AAEA,gD;;AAEA,G;AACA,kC;AACA,G;AACA,8C;;AAEA,G;AACA,iD;AACA,G;AACA,sC;AACA,mC;AACA,E;;AAEA,G;AACA,uD;AACA,G;AACA,2D;AACA,kB;;AAEA,4E;AACA,oF;;AAEA,qC;AACA,+E;AACA,+D;AACA,uD;;AAEA,wD;AACA,4B;AACA,2B;AACA,Y;;AAEA,c;AACA,gC;AACA,6B;;AAEA,qB;AACA,oC;;AAEA,gC;AACA,mD;AACA,U;AACA,4D;AACA,8B;;AAEA,iD;;AAEA,0B;AACA,oC;;AAEA,iD;AACA,8D;AACA,gC;AACA,yB;AACA,mB;AACA,a;AACA,K;;AAEA,kE;AACA,uB;AACA,0D;AACA,2E;AACA,8E;AACA,6E;AACA,yE;AACA,oB;AACA,Q;AACA,2B;AACA,iD;AACA,+D;AACA,yB;AACA,+B;AACA,yB;AACA,0B;AACA,a;AACA,Q;AACA,K;;AAEA,0E;AACA,oE;AACA,gE;AACA,wE;AACA,iD;AACA,gC;AACA,kB;AACA,gL;AACA,K;;AAEA,+D;AACA,wE;AACA,+D;AACA,mD;AACA,uB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACjGA,G;AACA,iD;AACA,G;AACA,qD;AACA,4C;AACA,E;;AAEA,G;AACA,sD;AACA,G;AACA,0D;AACA,iD;AACA,E;;;;;;;;;;;;;;;;;;;ACZA,yB;;AAEA,sB;AACA,uD;AACA,C","sourcesContent":["/**\n * Allows for dynamic scoping of options variables. Primarily intended to be\n * used in the RouteController.prototype.lookupOption method.\n */\nCurrentOptions = new Meteor.EnvironmentVariable;\n","HTTP_METHODS = [\n  'get',\n  'post',\n  'put',\n  'delete',\n];\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\nRouteController = Controller.extend({\n  constructor: function (options) {\n    RouteController.__super__.constructor.apply(this, arguments);\n    options = options || {};\n    this.options = options;\n    this._onStopCallbacks = [];\n    this.route = options.route;\n    this.params = [];\n\n    // Sometimes the data property can be defined on route options,\n    // or even on the global router config. And people will expect the\n    // data function to be available on the controller instance if it\n    // is defined anywhere in the chain. This ensure that if we have\n    // a data function somewhere in the chain, you can call this.data().\n    var data = this.lookupOption('data');\n\n    if (typeof data === 'function')\n      this.data = _.bind(data, this);\n    else if (typeof data !== 'undefined')\n      this.data = function () { return data; };\n\n    this.init(options);\n  }\n});\n\n/**\n * Returns an option value following an \"options chain\" which is this path:\n *\n *   this.options\n *   this (which includes the proto chain)\n *   this.route.options\n *   dynamic variable\n *   this.router.options\n */\nRouteController.prototype.lookupOption = function (key) {\n  // this.route.options\n  // NOTE: we've debated whether route options should come before controller but\n  // Tom has convinced me that it's easier for people to think about overriding\n  // controller stuff at the route option level. However, this has the possibly\n  // counterintuitive effect that if you define this.someprop = true on the\n  // controller instance, and you have someprop defined as an option on your\n  // Route, the route option will take precedence.\n  if (this.route && this.route.options && _.has(this.route.options, key))\n    return this.route.options[key];\n\n  // this.options\n  if (_.has(this.options, key))\n    return this.options[key];\n\n  // \"this\" object or its proto chain\n  if (typeof this[key] !== 'undefined')\n    return this[key];\n\n  // see if we have the CurrentOptions dynamic variable set.\n  var opts = CurrentOptions.get();\n  if (opts && _.has(opts, key))\n    return opts[key];\n\n  // this.router.options\n  if (this.router && this.router.options && _.has(this.router.options, key))\n    return this.router.options[key];\n};\n\nRouteController.prototype.configureFromUrl = function (url, context, options) {\n  assert(typeof url === 'string', 'url must be a string');\n  context = context || {};\n  this.request = context.request || {};\n  this.response = context.response || {};\n  this.url = context.url || url;\n  this.originalUrl = context.originalUrl || url;\n  this.method = this.request.method;\n  if (this.route) {\n    // pass options to that we can set reactive: false\n    this.setParams(this.route.params(url), options);\n  }\n};\n\n/**\n * Returns an array of hook functions for the given hook names. Hooks are\n * collected in this order:\n *\n * router global hooks\n * route option hooks\n * prototype of the controller\n * this object for the controller\n *\n * For example, this.collectHooks('onBeforeAction', 'before')\n * will return an array of hook functions where the key is either onBeforeAction\n * or before.\n *\n * Hook values can also be strings in which case they are looked up in the\n * Iron.Router.hooks object.\n *\n * TODO: Add an options last argument which can specify to only collect hooks\n * for a particular environment (client, server or both).\n */\nRouteController.prototype._collectHooks = function (/* hook1, alias1, ... */) {\n  var self = this;\n  var hookNames = _.toArray(arguments);\n\n  var getHookValues = function (value) {\n    if (!value)\n      return [];\n    var lookupHook = self.router.lookupHook;\n    var hooks = _.isArray(value) ? value : [value];\n    return _.map(hooks, function (h) { return lookupHook(h); });\n  };\n\n  var collectInheritedHooks = function (ctor, hookName) {\n    var hooks = [];\n\n    if (ctor.__super__)\n      hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor, hookName));\n\n    return _.has(ctor.prototype, hookName) ?\n      hooks.concat(getHookValues(ctor.prototype[hookName])) : hooks;\n  };\n\n  var eachHook = function (cb) {\n    for (var i = 0; i < hookNames.length; i++) {\n      cb(hookNames[i]);\n    }\n  };\n\n  var routerHooks = [];\n  eachHook(function (hook) {\n    var name = self.route && self.route.getName();\n    var hooks = self.router.getHooks(hook, name);\n    routerHooks = routerHooks.concat(hooks);\n  });\n\n  var protoHooks = [];\n  eachHook(function (hook) {\n    var hooks = collectInheritedHooks(self.constructor, hook);\n    protoHooks = protoHooks.concat(hooks);\n  });\n\n  var thisHooks = [];\n  eachHook(function (hook) {\n    if (_.has(self, hook)) {\n      var hooks = getHookValues(self[hook]);\n      thisHooks = thisHooks.concat(hooks);\n    }\n  });\n\n  var routeHooks = [];\n  if (self.route) {\n    eachHook(function (hook) {\n      var hooks = getHookValues(self.route.options[hook]);\n      routeHooks = routeHooks.concat(hooks);\n    });\n  }\n\n  var allHooks = routerHooks\n    .concat(routeHooks)\n    .concat(protoHooks)\n    .concat(thisHooks);\n\n  return allHooks;\n};\n\n/**\n * Runs each hook and returns the number of hooks that were run.\n */\nRouteController.prototype.runHooks = function (/* hook, alias1, ...*/ ) {\n  var hooks = this._collectHooks.apply(this, arguments);\n  for (var i = 0, l = hooks.length; i < l; i++) {\n    var h = hooks[i];\n    h.call(this);\n  }\n  return hooks.length;\n};\n\nRouteController.prototype.getParams = function () {\n  return this.params;\n};\n\nRouteController.prototype.setParams = function (value) {\n  this.params = value;\n  return this;\n};\n\nIron.RouteController = RouteController;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Fiber = Npm.require('fibers');\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\n\n/**\n * Server specific initialization.\n */\nRouteController.prototype.init = function (options) {};\n\n/**\n * Let this controller run a dispatch process. This function will be called\n * from the router. That way, any state associated with the dispatch can go on\n * the controller instance. Note: no result returned from dispatch because its\n * run inside its own fiber. Might at some point move the fiber stuff to a\n * higher layer.\n */\nRouteController.prototype.dispatch = function (stack, url, done) {\n  var self = this;\n  Fiber(function () {\n    stack.dispatch(url, self, done);\n  }).run();\n};\n\n/**\n * Run a route on the server. When the router runs its middleware stack, it\n * can run regular middleware functions or it can run a route. There should\n * only one route object per path as where there may be many middleware\n * functions.\n *\n * For example:\n *\n *   \"/some/path\" => [middleware1, middleware2, route, middleware3]\n *\n * When a route is dispatched, it tells the controller to _runRoute so that\n * the controller can control the process. At this point we should already be\n * in a dispatch so a computation should already exist.\n */\nRouteController.prototype._runRoute = function (route, url, done) {\n  var self = this;\n  var stack = new MiddlewareStack;\n\n  var onRunHooks = this._collectHooks('onRun', 'load');\n  stack = stack.append(onRunHooks, {where: 'server'});\n\n  var beforeHooks = this._collectHooks('onBeforeAction', 'before');\n  stack.append(beforeHooks, {where: 'server'});\n\n  // make sure the action stack has at least one handler on it that defaults\n  // to the 'action' method\n  if (route._actionStack.length === 0) {\n    route._actionStack.push(route._path, 'action', route.options);\n  }\n\n  stack = stack.concat(route._actionStack);\n  stack.dispatch(url, this, done);\n\n  // run the after hooks.\n  this.next = function () {};\n  this.runHooks('onAfterAction', 'after');\n};\n","var Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* Both */\n/*****************************************************************************/\nRoute = function (path, fn, options) {\n  var route = function (req, res, next) {\n    var controller = this;\n    controller.request = req;\n    controller.response = res;\n    route.dispatch(req.url, controller, next);\n  }\n\n  if (typeof fn === 'object') {\n    options = fn;\n    fn = options.action;\n  }\n\n  options = options || {};\n\n  if (typeof path === 'string' && path.charAt(0) !== '/') {\n    path = options.path ? options.path : '/' + path\n  }\n\n  // extend the route function with properties from this instance and its\n  // prototype.\n  _.extend(route, this);\n\n  // always good to have options\n  options = route.options = options || {};\n\n  // the main action function as well as any HTTP VERB action functions will go\n  // onto this stack.\n  route._actionStack = new MiddlewareStack;\n\n  // any before hooks will go onto this stack to make sure they get executed\n  // before the action stack.\n  route._beforeStack = new MiddlewareStack;\n  route._beforeStack.append(route.options.onBeforeAction);\n  route._beforeStack.append(route.options.before);\n\n  // after hooks get run after the action stack\n  route._afterStack = new MiddlewareStack;\n  route._afterStack.append(route.options.onAfterAction);\n  route._afterStack.append(route.options.after);\n\n\n  // track which methods this route uses\n  route._methods = {};\n\n  if (typeof fn === 'string') {\n    route._actionStack.push(path, _.extend(options, {\n      template: fn\n    }));\n  } else if (typeof fn === 'function' || typeof fn === 'object') {\n    route._actionStack.push(path, fn, options);\n  }\n\n  route._path = path;\n  return route;\n};\n\n/**\n * The name of the route is actually stored on the handler since a route is a\n * function that has an unassignable \"name\" property.\n */\nRoute.prototype.getName = function () {\n  return this.handler && this.handler.name;\n};\n\n/**\n * Returns an appropriate RouteController constructor the this Route.\n *\n * There are three possibilities:\n *\n *  1. controller option provided as a string on the route\n *  2. a controller in the global namespace with the converted name of the route\n *  3. a default RouteController\n *\n */\nRoute.prototype.findControllerConstructor = function () {\n  var self = this;\n\n  var resolve = function (name, opts) {\n    opts = opts || {};\n    var C = Iron.utils.resolve(name);\n    if (!C || !RouteController.prototype.isPrototypeOf(C.prototype)) {\n      if (opts.supressErrors !== true)\n        throw new Error(\"RouteController '\" + name + \"' is not defined.\");\n      else\n        return undefined;\n    } else {\n      return C;\n    }\n  };\n\n  var convert = function (name) {\n    return self.router.toControllerName(name);\n  };\n\n  var result;\n  var name = this.getName();\n\n  // the controller was set directly\n  if (typeof this.options.controller === 'function')\n    return this.options.controller;\n\n  // was the controller specified precisely by name? then resolve to an actual\n  // javascript constructor value\n  else if (typeof this.options.controller === 'string')\n    return resolve(this.options.controller);\n\n  // otherwise do we have a name? try to convert the name to a controller name\n  // and resolve it to a value\n  else if (name && (result = resolve(convert(name), {supressErrors: true})))\n    return result;\n\n  // otherwise just use an anonymous route controller\n  else\n    return RouteController;\n};\n\n\n/**\n * Create a new controller for the route.\n */\nRoute.prototype.createController = function (options) {\n  options = options || {};\n  var C = this.findControllerConstructor();\n  options.route = this;\n  var instance = new C(options);\n  return instance;\n};\n\nRoute.prototype.setControllerParams = function (controller, url) {\n};\n\n/**\n * Dispatch into the route's middleware stack.\n */\nRoute.prototype.dispatch = function (url, context, done) {\n  // call runRoute on the controller which will behave similarly to the previous\n  // version of IR.\n  assert(context._runRoute, \"context doesn't have a _runRoute method\");\n  return context._runRoute(this, url, done);\n};\n\n/**\n * Returns a relative path for the route.\n */\nRoute.prototype.path = function (params, options) {\n  return this.handler.resolve(params, options);\n};\n\n/**\n * Return a fully qualified url for the route, given a set of parmeters and\n * options like hash and query.\n */\nRoute.prototype.url = function (params, options) {\n  var path = this.path(params, options);\n  var host = (options && options.host) || Meteor.absoluteUrl();\n\n  if (host.charAt(host.length-1) === '/');\n    host = host.slice(0, host.length-1);\n  return host + path;\n};\n\n/**\n * Return a params object for the route given a path.\n */\nRoute.prototype.params = function (path) {\n  return this.handler.params(path);\n};\n\n/**\n * Add convenience methods for each HTTP verb.\n *\n * Example:\n *  var route = router.route('/item')\n *    .get(function () { })\n *    .post(function () { })\n *    .put(function () { })\n */\nHTTP_METHODS.forEach(function (method) {\n  Route.prototype[method] = function (fn) {\n    // track the method being used for OPTIONS requests.\n    this._methods[method] = true;\n\n    this._actionStack.push(this._path, fn, {\n      // give each method a unique name so it doesn't clash with the route's\n      // name in the action stack\n      name: this.getName() + '_' + method.toLowerCase(),\n      method: method,\n\n      // for now just make the handler where the same as the route, presumably a\n      // server route.\n      where: this.handler.where,\n      mount: false\n    });\n\n    return this;\n  };\n});\n\nIron.Route = Route;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar Url = Iron.Url;\nvar Layout = Iron.Layout;\nvar warn = Iron.utils.warn;\nvar assert = Iron.utils.assert;\n\nRouter = function (options) {\n  // keep the same api throughout which is:\n  // fn(url, context, done);\n  function router (req, res, next) {\n    //XXX this assumes no other routers on the parent stack which we should probably fix\n    router.dispatch(req.url, {\n      request: req,\n      response: res\n    }, next);\n  }\n\n  // the main router stack\n  router._stack = new MiddlewareStack;\n\n  // for storing global hooks like before, after, etc.\n  router._globalHooks = {};\n\n  // backward compat and quicker lookup of Route handlers vs. regular function\n  // handlers.\n  router.routes = [];\n\n  // to make sure we don't have more than one route per path\n  router.routes._byPath = {};\n\n  // always good to have options\n  this.configure.call(router, options);\n\n  // add proto properties to the router function\n  _.extend(router, this);\n\n  // let client and server side routing doing different things here\n  this.init.call(router, options);\n\n  Meteor.startup(function () {\n    Meteor.defer(function () {\n      if (router.options.autoStart !== false)\n        router.start();\n    });\n  });\n\n  return router;\n};\n\nRouter.prototype.init = function (options) {};\n\nRouter.prototype.configure = function (options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (value) {\n    if (!value)\n      return [];\n\n    if (_.isArray(value))\n      return value;\n\n    return [value];\n  };\n\n  // e.g. before: fn OR before: [fn1, fn2]\n  _.each(Iron.Router.HOOK_TYPES, function eachHookType (type) {\n    if (options[type]) {\n      _.each(toArray(options[type]), function eachHook (hook) {\n        self.addHook(type, hook);\n      });\n\n      delete options[type];\n    }\n  });\n\n  this.options = this.options || {};\n  _.extend(this.options, options);\n\n  return this;\n};\n\n/**\n * Just to support legacy calling. Doesn't really serve much purpose.\n */\nRouter.prototype.map = function (fn) {\n  return fn.call(this);\n};\n\n/*\n * XXX removing for now until this is thought about more carefully.\nRouter.prototype.use = function (path, fn, opts) {\n  if (typeof path === 'function') {\n    opts = fn || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, opts);\n  } else {\n    opts = opts || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, fn, opts);\n  }\n\n  return this;\n};\n*/\n\n//XXX seems like we could put a params method on the route directly and make it reactive\nRouter.prototype.route = function (path, fn, opts) {\n  var typeOf = function (val) { return Object.prototype.toString.call(val); };\n  assert(typeOf(path) === '[object String]' || typeOf(path) === '[object RegExp]', \"Router.route requires a path that is a string or regular expression.\");\n\n  if (typeof fn === 'object') {\n    opts = fn;\n    fn = opts.action;\n  }\n\n  var route = new Route(path, fn, opts);\n\n  opts = opts || {};\n\n  // don't mount the route\n  opts.mount = false;\n\n  // stack expects a function which is exactly what a new Route returns!\n  var handler = this._stack.push(path, route, opts);\n\n  handler.route = route;\n  route.handler = handler;\n  route.router = this;\n  \n  assert(!this.routes._byPath[handler.path],\n    \"A route for the path \" + JSON.stringify(handler.path) + \" already exists by the name of \" + JSON.stringify(handler.name) + \".\");\n  this.routes._byPath[handler.path] = route;\n\n  this.routes.push(route);\n\n  if (typeof handler.name === 'string')\n    this.routes[handler.name] = route;\n\n  return route;\n};\n\n/**\n * Find the first route for the given url and options.\n */\nRouter.prototype.findFirstRoute = function (url) {\n  for (var i = 0; i < this.routes.length; i++) {\n    if (this.routes[i].handler.test(url, {}))\n      return this.routes[i];\n  }\n\n  return null;\n};\n\nRouter.prototype.path = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.path for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.path(params, options);\n};\n\nRouter.prototype.url = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.url for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.url(params, options);\n};\n\n/**\n * Create a new controller for a dispatch.\n */\nRouter.prototype.createController = function (url, context) {\n  // see if there's a route for this url\n  var route = this.findFirstRoute(url);\n  var controller;\n\n  context = context || {};\n\n  if (route)\n    // let the route decide what controller to use\n    controller = route.createController({layout: this._layout});\n  else\n    // create an anonymous controller\n    controller = new RouteController({layout: this._layout});\n\n  controller.router = this;\n  controller.configureFromUrl(url, context, {reactive: false});\n  return controller;\n};\n\nRouter.prototype.setTemplateNameConverter = function (fn) {\n  this._templateNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.setControllerNameConverter = function (fn) {\n  this._controllerNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.toTemplateName = function (str) {\n  if (this._templateNameConverter)\n    return this._templateNameConverter(str);\n  else\n    return Iron.utils.classCase(str);\n};\n\nRouter.prototype.toControllerName = function (str) {\n  if (this._controllerNameConverter)\n    return this._controllerNameConverter(str);\n  else\n    return Iron.utils.classCase(str) + 'Controller';\n};\n\n/**\n *\n * Add a hook to all routes. The hooks will apply to all routes,\n * unless you name routes to include or exclude via `only` and `except` options\n *\n * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n * @param {Object} [options] Options to controll the hooks [optional]\n * @param {Function} [hook] Callback to run\n * @return {IronRouter}\n * @api public\n *\n */\n\nRouter.prototype.addHook = function(type, hook, options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (input) {\n    if (!input)\n      return [];\n    else if (_.isArray(input))\n      return input;\n    else\n      return [input];\n  }\n\n  if (options.only)\n    options.only = toArray(options.only);\n  if (options.except)\n    options.except = toArray(options.except);\n\n  var hooks = this._globalHooks[type] = this._globalHooks[type] || [];\n\n  var hookWithOptions = function () {\n    var thisArg = this;\n    var args = arguments;\n    // this allows us to bind hooks to options that get looked up when you call\n    // this.lookupOption from within the hook. And it looks better to keep\n    // plugin/hook related options close to their definitions instead of\n    // Router.configure. But we use a dynamic variable so we don't have to\n    // pass the options explicitly as an argument and plugin creators can\n    // just use this.lookupOption which will follow the proper lookup chain from\n    // \"this\", local options, dynamic variable options, route, router, etc.\n    return CurrentOptions.withValue(options, function () {\n      return self.lookupHook(hook).apply(thisArg, args);\n    });\n  };\n\n  hooks.push({options: options, hook: hookWithOptions});\n  return this;\n};\n\n/**\n * If the argument is a function return it directly. If it's a string, see if\n * there is a function in the Iron.Router.hooks namespace. Throw an error if we\n * can't find the hook.\n */\nRouter.prototype.lookupHook = function (nameOrFn) {\n  var fn = nameOrFn;\n\n  // if we already have a func just return it\n  if (_.isFunction(fn))\n    return fn;\n\n  // look up one of the out-of-box hooks like\n  // 'loaded or 'dataNotFound' if the nameOrFn is a\n  // string\n  if (_.isString(fn)) {\n    if (_.isFunction(Iron.Router.hooks[fn]))\n      return Iron.Router.hooks[fn];\n  }\n\n  // we couldn't find it so throw an error\n  throw new Error(\"No hook found named: \" + nameOrFn);\n};\n\n/**\n *\n * Fetch the list of global hooks that apply to the given route name.\n * Hooks are defined by the .addHook() function above.\n *\n * @param {String} [type] one of IronRouter.HOOK_TYPES\n * @param {String} [name] the name of the route we are interested in\n * @return {[Function]} [hooks] an array of hooks to run\n * @api public\n *\n */\n\nRouter.prototype.getHooks = function(type, name) {\n  var self = this;\n  var hooks = [];\n\n  _.each(this._globalHooks[type], function(hook) {\n    var options = hook.options;\n\n    if (options.except && _.include(options.except, name))\n      return [];\n\n    if (options.only && ! _.include(options.only, name))\n      return [];\n\n    hooks.push(hook.hook);\n  });\n\n  return hooks;\n};\n\nRouter.HOOK_TYPES = [\n  'onRun',\n  'onRerun',\n  'onBeforeAction',\n  'onAfterAction',\n  'onStop',\n\n  // not technically a hook but we'll use it\n  // in a similar way. This will cause waitOn\n  // to be added as a method to the Router and then\n  // it can be selectively applied to specific routes\n  'waitOn',\n\n  // legacy hook types but we'll let them slide\n  'load', // onRun\n  'before', // onBeforeAction\n  'after', // onAfterAction\n  'unload' // onStop\n];\n\n/**\n * A namespace for hooks keyed by name.\n */\nRouter.hooks = {};\n\n\n/**\n * A namespace for plugin functions keyed by name.\n */\nRouter.plugins = {};\n\n/**\n * Auto add helper mtehods for all the hooks.\n */\n\nRouter.HOOK_TYPES.forEach(function (type) {\n  Router.prototype[type] = function (hook, options) {\n    this.addHook(type, hook, options);\n  };\n});\n\n/**\n * Add a plugin to the router instance.\n */\nRouter.prototype.plugin = function (nameOrFn, options) {\n  var func;\n\n  if (typeof nameOrFn === 'function')\n    func = nameOrFn;\n  else if (typeof nameOrFn === 'string')\n    func = Iron.Router.plugins[nameOrFn];\n\n  if (!func)\n    throw new Error(\"No plugin found named \" + JSON.stringify(nameOrFn));\n\n  // fn(router, options)\n  func.call(this, this, options);\n\n  return this;\n};\n\nIron.Router = Router;\n","if (typeof Template !== 'undefined') {\n  /**\n   * The default anonymous loading template.\n   */\n  var defaultLoadingTemplate = new Template('DefaultLoadingTemplate', function () {\n    return 'Loading...';\n  });\n\n  /**\n   * The default anonymous data not found template.\n   */\n  var defaultDataNotFoundTemplate = new Template('DefaultDataNotFoundTemplate', function () {\n    return 'Data not found...';\n  });\n}\n\n/**\n * Automatically render a loading template into the main region if the\n * controller is not ready (i.e. this.ready() is false). If no loadingTemplate\n * is defined use some default text.\n */\n\nRouter.hooks.loading = function () {\n  // if we're ready just pass through\n  if (this.ready()) {\n    this.next();\n    return;\n  }\n\n  var template = this.lookupOption('loadingTemplate');\n  this.render(template || defaultLoadingTemplate);\n  this.renderRegions();\n};\n\n/**\n * Render a \"data not found\" template if a global data function returns a falsey\n * value\n */\nRouter.hooks.dataNotFound = function () {\n  if (!this.ready()) {\n    this.next();\n    return;\n  }\n\n  var data = this.lookupOption('data');\n  var dataValue;\n  var template = this.lookupOption('notFoundTemplate');\n\n  if (typeof data === 'function') {\n    if (!(dataValue = data.call(this))) {\n      this.render(template || defaultDataNotFoundTemplate);\n      this.renderRegions();\n      return;\n    }\n  }\n\n  // okay never mind just pass along now\n  this.next();\n};\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar warn = Iron.utils.warn;\nvar DynamicTemplate = Iron.DynamicTemplate;\nvar debug = Iron.utils.debug('iron:router <helpers>');\n\n/*****************************************************************************/\n/* UI Helpers */\n/*****************************************************************************/\n\n/**\n * Render the Router to a specific location on the page instead of the\n * document.body. \n */\nUI.registerHelper('Router', new Blaze.Template('Router', function () {\n  return Router.createView();\n}));\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('pathFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"pathFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  return path;\n});\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('urlFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n  var url = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"urlFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    url = route.url(data, {query: query, hash: hash});\n  }\n\n  return url;\n});\n\n/**\n * Create a link with optional content block.\n *\n * Example:\n *   {{#linkTo route=\"one\" query=\"query\" hash=\"hash\" class=\"my-cls\"}}\n *    <div>My Custom Link Content</div>\n *   {{/linkTo}}\n */\nUI.registerHelper('linkTo', new Blaze.Template('linkTo', function () {\n  var self = this;\n  var opts = DynamicTemplate.getInclusionArguments(this);\n\n  if (typeof opts !== 'object')\n    throw new Error(\"linkTo options must be key value pairs such as {{#linkTo route='my.route.name'}}. You passed: \" + JSON.stringify(opts));\n\n  opts = opts || {};\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = opts.route;\n  var data = _.extend({}, opts.data || DynamicTemplate.getParentDataContext(this));\n  var route = Router.routes[routeName];\n  var paramKeys;\n\n  warn(route, \"linkTo couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  // anything that isn't one of our keywords we'll assume is an attributed\n  // intended for the <a> tag\n  var attrs = _.omit(opts, 'route', 'query', 'hash', 'data');\n  attrs.href = path;\n\n  return Blaze.With(function () {\n    return DynamicTemplate.getParentDataContext(self);\n  }, function () {\n    return HTML.A(attrs, self.templateContentBlock);\n  });\n}));\n","Router.bodyParser = Npm.require('body-parser');\n","var assert = Iron.utils.assert;\n\nvar env = process.env.NODE_ENV || 'development';\n\n/**\n * Server specific initialization.\n */\nRouter.prototype.init = function (options) {};\n\n/**\n * Add the router to the server connect handlers.\n */\nRouter.prototype.start = function () {\n  WebApp.connectHandlers.use(this);\n};\n\n/**\n * Create a new controller and dispatch into the stack.\n */\nRouter.prototype.dispatch = function (url, context, done) {\n  var self = this;\n\n  assert(typeof url === 'string', \"expected url string in router dispatch\");\n  assert(typeof context === 'object', \"expected context object in router dispatch\");\n\n  // assumes there is only one router\n  // XXX need to initialize controller either from the context itself or if the\n  // context already has a controller on it, just use that one.\n  var controller = this.createController(url, context);\n\n  controller.dispatch(this._stack, url, function (err) {\n    var res = this.response;\n    var req = this.request;\n    var msg;\n\n    if (err) {\n      if (res.statusCode < 400) \n        res.statusCode = 500;\n\n      if (err.status)\n        res.statusCode = err.status;\n\n      if (env === 'development')\n        msg = (err.stack || err.toString()) + '\\n';\n      else\n        //XXX get this from standard dict of error messages?\n        msg = 'Server error.';\n\n      console.error(err.stack || err.toString());\n\n      if (res.headersSent)\n        return req.socket.destroy();\n\n      res.setHeader('Content-Type', 'text/html');\n      res.setHeader('Content-Length', Buffer.byteLength(msg));\n      if (req.method === 'HEAD')\n        return res.end();\n      res.end(msg);\n      return;\n    }\n\n    // if there are no client or server handlers for this dispatch\n    // then send a 404.\n    // XXX we need a solution here for 404s on bad routes.\n    //     one solution might be to provide a custom 404 page in the public\n    //     folder. But we need a proper way to handle 404s for search engines.\n    // XXX might be a PR to Meteor to use an existing status code if it's set\n    if (!controller.isHandled() && !controller.willBeHandledOnClient()) {\n      return done();\n      /*\n      res.statusCode = 404;\n      res.setHeader('Content-Type', 'text/html');\n      msg = req.method + ' ' + req.originalUrl + ' not found.';\n      console.error(msg);\n      if (req.method == 'HEAD')\n        return res.end();\n      res.end(msg + '\\n');\n      return;\n      */\n    }\n\n    // if for some reason there was a server handler but no client handler\n    // and the server handler called next() we might end up here. We\n    // want to make sure to end the response so it doesn't hang.\n    if (controller.isHandled() && !controller.willBeHandledOnClient()) {\n      res.setHeader('Content-Type', 'text/html');\n      if (req.method === 'HEAD')\n        res.end();\n      res.end(\"<p>It looks like you don't have any client routes defined, but you had at least one server handler. You probably want to define some client side routes!</p>\\n\");\n    }\n\n    // we'll have Meteor load the normal application so long as\n    // we have at least one client route/handler and the done() iterator\n    // function has been passed to us, presumably from Connect.\n    if (controller.willBeHandledOnClient() && done)\n      return done(err);\n  });\n};\n","/**\n * Simple plugin wrapper around the loading hook.\n */\nRouter.plugins.loading = function (router, options) {\n  router.onBeforeAction('loading', options);\n};\n\n/**\n * Simple plugin wrapper around the dataNotFound hook.\n */\nRouter.plugins.dataNotFound = function (router, options) {\n  router.onBeforeAction('dataNotFound', options);\n};\n","Router = new Iron.Router;\n\nif (Meteor.isServer) {\n  Router.onBeforeAction(Iron.Router.bodyParser.json());\n}\n"]}