{"version":3,"file":"/packages/application-configuration.js","sources":["application-configuration/config.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,0C;;AAEA,e;;;AAGA,2C;AACA,+E;AACA,gB;AACA,G;AACA,qF;AACA,G;;AAEA,mC;;AAEA,6B;AACA,iC;AACA,Y;AACA,0E;AACA,8E;AACA,C;;AAEA,S;AACA,S;AACA,a;AACA,oC;;AAEA,4B;AACA,kC;AACA,c;AACA,yC;AACA,uB;AACA,O;AACA,yC;AACA,uB;AACA,O;AACA,iD;AACA,uB;AACA,O;AACA,uD;AACA,8B;AACA,G;AACA,G;;AAEA,+E;AACA,U;AACA,2C;AACA,0B;AACA,c;AACA,E;;AAEA,4C;AACA,0B;AACA,c;AACA,E;;;AAGA,oB;;AAEA,K;AACA,+B;AACA,yD;AACA,U;AACA,iB;AACA,S;AACA,wC;AACA,2D;AACA,O;AACA,iB;AACA,0D;AACA,K;AACA,uB;AACA,yB;AACA,iB;AACA,2B;AACA,qC;AACA,4C;AACA,S;AACA,O;AACA,M;AACA,G;AACA,a;AACA,sE;AACA,E;;AAEA,sC;AACA,mD;AACA,2B;AACA,G;AACA,mB;AACA,mD;AACA,e;AACA,2D;AACA,G;AACA,4B;AACA,gB;AACA,E;;AAEA,2C;AACA,c;AACA,yB;AACA,mD;AACA,c;AACA,sB;AACA,K;AACA,G;AACA,c;AACA,E;;AAEA,gE;AACA,mF;AACA,0E;AACA,kB;AACA,2C;AACA,gD;;AAEA,gF;AACA,2D;AACA,+E;AACA,8C;AACA,wB;AACA,6C;AACA,sB;AACA,iF;AACA,yB;AACA,oD;AACA,4B;AACA,K;AACA,I;AACA,gB;AACA,8B;;AAEA,6E;AACA,U;AACA,6B;AACA,6E;AACA,6C;AACA,4B;AACA,2D;AACA,kC;AACA,mC;AACA,O;AACA,sB;AACA,K;;AAEA,U;AACA,uB;AACA,sB;AACA,uB;AACA,K;AACA,I;AACA,E;;AAEA,yE;;AAEA,8E;AACA,gF;AACA,wB;AACA,sC;AACA,qC;AACA,wB;AACA,sB;AACA,O;AACA,uB;AACA,+C;AACA,iC;AACA,+D;AACA,mC;AACA,W;AACA,c;AACA,4C;AACA,O;AACA,O;AACA,yB;AACA,I;;AAEA,c;AACA,6E;AACA,6C;AACA,4B;AACA,8E;AACA,+E;AACA,0D;AACA,uD;AACA,+B;AACA,gC;AACA,yD;AACA,S;AACA,O;AACA,O;AACA,0B;AACA,wB;AACA,sB;AACA,gB;AACA,2B;AACA,6B;AACA,4B;AACA,O;AACA,G;;AAEA,E","sourcesContent":["var Future = Npm.require(\"fibers/future\");\n\nAppConfig = {};\n\n\nAppConfig.findGalaxy = _.once(function () {\n  if (!('GALAXY' in process.env || 'ULTRAWORLD_DDP_ENDPOINT' in process.env)) {\n    return null;\n  }\n  return Follower.connect(process.env.ULTRAWORLD_DDP_ENDPOINT || process.env.GALAXY);\n});\n\nvar ultra = AppConfig.findGalaxy();\n\nvar subFuture = new Future();\nvar subFutureJobs = new Future();\nif (ultra) {\n  ultra.subscribe(\"oneApp\", process.env.GALAXY_APP, subFuture.resolver());\n  ultra.subscribe(\"oneJob\", process.env.GALAXY_JOB, subFutureJobs.resolver());\n}\n\nvar Apps;\nvar Jobs;\nvar Services;\nvar collectionFuture = new Future();\n\nMeteor.startup(function () {\n  var Mongo = Package.mongo.Mongo;\n  if (ultra) {\n    Apps = new Mongo.Collection(\"apps\", {\n      connection: ultra\n    });\n    Jobs = new Mongo.Collection(\"jobs\", {\n      connection: ultra\n    });\n    Services = new Mongo.Collection('services', {\n      connection: ultra\n    });\n    // allow us to block on the collections being ready\n    collectionFuture.return();\n  }\n});\n\n// XXX: Remove this once we allow the same collection to be new'd from multiple\n// places.\nAppConfig._getAppCollection = function () {\n  collectionFuture.wait();\n  return Apps;\n};\n\nAppConfig._getJobsCollection = function () {\n  collectionFuture.wait();\n  return Jobs;\n};\n\n\nvar staticAppConfig;\n\ntry {\n  if (process.env.APP_CONFIG) {\n    staticAppConfig = JSON.parse(process.env.APP_CONFIG);\n  } else {\n    var settings;\n    try {\n      if (process.env.METEOR_SETTINGS) {\n        settings = JSON.parse(process.env.METEOR_SETTINGS);\n      }\n    } catch (e) {\n      Log.warn(\"Could not parse METEOR_SETTINGS as JSON\");\n    }\n    staticAppConfig = {\n      settings: settings,\n      packages: {\n        'mongo-livedata': {\n          url: process.env.MONGO_URL,\n          oplog: process.env.MONGO_OPLOG_URL\n        }\n      }\n    };\n  }\n} catch (e) {\n  Log.warn(\"Could not parse initial APP_CONFIG environment variable\");\n};\n\nAppConfig.getAppConfig = function () {\n  if (!subFuture.isResolved() && staticAppConfig) {\n    return staticAppConfig;\n  }\n  subFuture.wait();\n  var myApp = Apps.findOne(process.env.GALAXY_APP);\n  if (!myApp) {\n    throw new Error(\"there is no app config for this app\");\n  }\n  var config = myApp.config;\n  return config;\n};\n\nAppConfig.getStarForThisJob = function () {\n  if (ultra) {\n    subFutureJobs.wait();\n    var job = Jobs.findOne(process.env.GALAXY_JOB);\n    if (job) {\n      return job.star;\n    }\n  }\n  return null;\n};\n\nAppConfig.configurePackage = function (packageName, configure) {\n  var appConfig = AppConfig.getAppConfig(); // Will either be based in the env var,\n                                         // or wait for galaxy to connect.\n  var lastConfig =\n        (appConfig && appConfig.packages &&\n         appConfig.packages[packageName]) || {};\n\n  // Always call the configure callback \"soon\" even if the initial configuration\n  // is empty (synchronously, though deferred would be OK).\n  // XXX make sure that all callers of configurePackage deal well with multiple\n  // callback invocations!  eg, email does not\n  configure(lastConfig);\n  var configureIfDifferent = function (app) {\n    if (!EJSON.equals(\n           app.config && app.config.packages && app.config.packages[packageName],\n           lastConfig)) {\n      lastConfig = app.config.packages[packageName];\n      configure(lastConfig);\n    }\n  };\n  var subHandle;\n  var observed = new Future();\n\n  // This is not required to finish, so defer it so it doesn't block anything\n  // else.\n  Meteor.defer( function () {\n    // there's a Meteor.startup() that produces the various collections, make\n    // sure it runs first before we continue.\n    collectionFuture.wait();\n    subHandle = Apps.find(process.env.GALAXY_APP).observe({\n      added: configureIfDifferent,\n      changed: configureIfDifferent\n    });\n    observed.return();\n  });\n\n  return {\n    stop: function () {\n      observed.wait();\n      subHandle.stop();\n    }\n  };\n};\n\nAppConfig.configureService = function (serviceName, version, configure) {\n\n  // Collect all the endpoints for this service, from both old- and new-format\n  // documents, and call the `configure` callback with all the service endpoints\n  // that we know about.\n  var callConfigure = function (doc) {\n    var serviceDocs = Services.find({\n      name: serviceName,\n      version: version\n    });\n    var endpoints = [];\n    serviceDocs.forEach(function (serviceDoc) {\n      if (serviceDoc.providers) {\n        _.each(serviceDoc.providers, function (endpoint, app) {\n          endpoints.push(endpoint);\n        });\n      } else {\n        endpoints.push(serviceDoc.endpoint);\n      }\n    });\n    configure(endpoints);\n  };\n\n  if (ultra) {\n    // there's a Meteor.startup() that produces the various collections, make\n    // sure it runs first before we continue.\n    collectionFuture.wait();\n    // First try to subscribe to the new format service registrations; if that\n    // sub doesn't exist, then ultraworld hasn't updated to the new format yet,\n    // so try the old format `servicesByName` sub instead.\n    ultra.subscribe('services', serviceName, version, {\n      onError: function (err) {\n        if (err.error === 404) {\n          ultra.subscribe('servicesByName', serviceName);\n        }\n      }\n    });\n    return Services.find({\n      name: serviceName,\n      version: version\n    }).observe({\n      added: callConfigure,\n      changed: callConfigure,\n      removed: callConfigure\n    });\n  }\n\n};\n"]}